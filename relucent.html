<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>relucent package &#8212; relucent  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=fd6eb6e6"></script>
    <script src="_static/sphinx_highlight.js?v=6ffebe34"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="relucent-package">
<h1>relucent package<a class="headerlink" href="#relucent-package" title="Link to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
</section>
<section id="module-relucent.complex">
<span id="relucent-complex-module"></span><h2>relucent.complex module<a class="headerlink" href="#module-relucent.complex" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="relucent.complex.Complex">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">relucent.complex.</span></span><span class="sig-name descname"><span class="pre">Complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Manages the polyhedral complex of a neural network.</p>
<p>This class provides methods for calculating, storing, and searching the h-representations
(halfspace representations) of polyhedra in the complex.</p>
<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.add_point">
<span class="sig-name descname"><span class="pre">add_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numpy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.add_point" title="Link to this definition">¶</a></dt>
<dd><p>Find the polyhedron containing a data point and add it to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – A single data point as a torch.Tensor or np.ndarray.</p></li>
<li><p><strong>numpy</strong> – If True, treat input as numpy array. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The polyhedron containing the given point, now stored in the complex.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.Polyhedron" title="relucent.Polyhedron">Polyhedron</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.add_polyhedron">
<span class="sig-name descname"><span class="pre">add_polyhedron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.add_polyhedron" title="Link to this definition">¶</a></dt>
<dd><p>Add a Polyhedron to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – The Polyhedron object to add.</p></li>
<li><p><strong>overwrite</strong> – If True and the polyhedron already exists, replace it with
the new one. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The polyhedron that was added (or already existed) in the complex.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.Polyhedron" title="relucent.Polyhedron">Polyhedron</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.add_ss">
<span class="sig-name descname"><span class="pre">add_ss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_exists</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.add_ss" title="Link to this definition">¶</a></dt>
<dd><p>Convert a sign sequence to a Polyhedron and add it to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ss</strong> – A sign sequence as a torch.Tensor or np.ndarray.</p></li>
<li><p><strong>check_exists</strong> – If True, return the existing polyhedron from the complex
if it already exists. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The polyhedron that was added (or already existed) in the complex.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.Polyhedron" title="relucent.Polyhedron">Polyhedron</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.adjacent_polyhedra">
<span class="sig-name descname"><span class="pre">adjacent_polyhedra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.adjacent_polyhedra" title="Link to this definition">¶</a></dt>
<dd><p>Get the Polyhedra that are adjacent (across one BH) from the given Polyhedron.</p>
<p>Also works on lower-dimensional polyhedra.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.bfs">
<span class="sig-name descname"><span class="pre">bfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.bfs" title="Link to this definition">¶</a></dt>
<dd><p>Perform breadth-first search of the complex.</p>
<p>Explores the complex using a breadth-first strategy, discovering all
polyhedra at depth d before moving to depth d+1. Uses a FIFO queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – All arguments accepted by searcher().</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Search information dictionary (see searcher() documentation).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.clean_data">
<span class="sig-name descname"><span class="pre">clean_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.clean_data" title="Link to this definition">¶</a></dt>
<dd><p>Clean cached data from all polyhedra in the complex.</p>
<p>This method calls clean_data() on each polyhedron, which removes most of their
computed data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.dfs">
<span class="sig-name descname"><span class="pre">dfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.dfs" title="Link to this definition">¶</a></dt>
<dd><p>Perform depth-first search of the complex.</p>
<p>Explores the complex using a depth-first strategy, following paths as
deeply as possible before backtracking. Uses a LIFO queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – All arguments accepted by searcher().</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Search information dictionary (see searcher() documentation).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.get_dual_graph">
<span class="sig-name descname"><span class="pre">get_dual_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">relabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'viridis'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_locations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.get_dual_graph" title="Link to this definition">¶</a></dt>
<dd><p>Construct the dual graph of the complex.</p>
<p>The dual graph represents the connectivity structure of the complex,
where nodes are polyhedra and edges connect adjacent polyhedra (those
sharing a supporting hyperplane).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>relabel</strong> – If True, nodes are indexed by integers matching self.index2poly
indices. If False, nodes are Polyhedron objects. Defaults to False.</p></li>
<li><p><strong>plot</strong> – If True, prepare the graph for visualization with pyvis by
adding layout and styling attributes. Defaults to False.</p></li>
<li><p><strong>node_color</strong> – If “Wl2”, color nodes by their Wl2 (weight norm) value.
If “volume”, color by volume. If None, no special coloring.
Defaults to None.</p></li>
<li><p><strong>node_size</strong> – If “volume”, size nodes proportionally to their volume.
If None, use default size. Defaults to None.</p></li>
<li><p><strong>cmap</strong> – Colormap to use when node_color is specified. Defaults to “viridis”.</p></li>
<li><p><strong>match_locations</strong> – If True, position graph nodes at the center points
of their polyhedra (only works for 2D complexes). Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>The dual graph of the complex. Nodes are polyhedra</dt><dd><p>(or integers if relabel=True), edges connect adjacent polyhedra
and have a “shi” attribute indicating which supporting hyperplane
they cross.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkx.Graph</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If match_locations is True and the complex is not 2D.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.get_poly_attrs">
<span class="sig-name descname"><span class="pre">get_poly_attrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.get_poly_attrs" title="Link to this definition">¶</a></dt>
<dd><p>Extract specified attributes from all polyhedra in the complex.</p>
<p>Useful for building tabular representations or dataframes of polyhedra
properties. Attributes are returned in the same order as polyhedra were
added to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>attrs</strong> – A list of attribute names to extract (e.g., [“finite”, “Wl2”]).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A dictionary mapping attribute names to lists of attribute</dt><dd><p>values, with one value per polyhedron in the complex based on the order
they were added.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.greedy_path">
<span class="sig-name descname"><span class="pre">greedy_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.greedy_path" title="Link to this definition">¶</a></dt>
<dd><p>Greedily find a path between two data points.</p>
<p>Attempts to find a path through adjacent polyhedra from start to end
using a greedy strategy. This method can be slow for large complexes
as it explores many paths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> – Starting data point as torch.Tensor or np.ndarray.</p></li>
<li><p><strong>end</strong> – Ending data point as torch.Tensor or np.ndarray.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A list of Polyhedron objects representing the path</dt><dd><p>from start to end, or None if no path is found.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.hamming_astar">
<span class="sig-name descname"><span class="pre">hamming_astar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nworkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_polys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_pbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.hamming_astar" title="Link to this definition">¶</a></dt>
<dd><p>Find a path between two data points using A* search algorithm.</p>
<p>Uses the A* pathfinding algorithm with a heuristic based on Hamming
distance between sign sequences, plus Euclidean distance between interior
points to break ties. The heuristic should be admissible for optimal paths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> – Starting data point as torch.Tensor or np.ndarray.</p></li>
<li><p><strong>end</strong> – Ending data point as torch.Tensor or np.ndarray.</p></li>
<li><p><strong>nworkers</strong> – Number of worker processes for parallel computation.
Defaults to 1.</p></li>
<li><p><strong>bound</strong> – Constraint radius for numerical stability when computing halfspaces.
Important for numerical stability. Defaults to 1e5.</p></li>
<li><p><strong>max_polys</strong> – Maximum number of polyhedra to explore during search.
Defaults to infinity.</p></li>
<li><p><strong>show_pbar</strong> – Whether to display a progress bar. Defaults to True.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to get_shis().</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A list of Polyhedron objects representing the path</dt><dd><p>from start to end, or None if no path is found.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list or None</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the start point lies exactly on a neuron’s boundary.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.load">
<span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.load" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.parallel_add">
<span class="sig-name descname"><span class="pre">parallel_add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nworkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.parallel_add" title="Link to this definition">¶</a></dt>
<dd><p>Add multiple polyhedra from data points using parallel processing.</p>
<p>Processes a batch of data points in parallel, computing their corresponding
polyhedra and adding them to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> – A list or iterable of data points (each as torch.Tensor or np.ndarray).</p></li>
<li><p><strong>nworkers</strong> – Number of worker processes to use. If None, uses the number
of CPU cores. Defaults to None.</p></li>
<li><p><strong>bound</strong> – Constraint radius for numerical stability when computing halfspaces.
Defaults to 1e6.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to poly_calculations() and get_shis().</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A list of Polyhedron objects (or None for failed computations)</dt><dd><p>corresponding to the input points.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_regions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">highlight_regions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.plot" title="Link to this definition">¶</a></dt>
<dd><p>Plot the complex in 2D using plotly.</p>
<p>Creates a 2D visualization of the complex, showing all polyhedra as
regions in the input space. Only works for 2D input spaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label_regions</strong> – If True, add text labels showing each polyhedron’s
string representation at its center. Defaults to False.</p></li>
<li><p><strong>color</strong> – If “Wl2”, color polyhedra by their Wl2 (weight norm) value.
If None, use an equitable graph coloring. Defaults to None.</p></li>
<li><p><strong>highlight_regions</strong> – If provided, highlight these polyhedra in red.
Can be a list of Polyhedron objects or their string representations.
Defaults to None.</p></li>
<li><p><strong>ss_name</strong> – If True, use the full sign sequence as
the legend label for each polyhedron. Defaults to False.</p></li>
<li><p><strong>bound</strong> – Constraint radius for plotting bounds. Passed to each
polyhedron’s plot2d() method. Defaults to None.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to each polyhedron’s plot2d() method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A plotly figure containing the 2D plot</dt><dd><p>of the complex.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>plotly.graph_objects.Figure</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.plot3d">
<span class="sig-name descname"><span class="pre">plot3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_regions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">highlight_regions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.plot3d" title="Link to this definition">¶</a></dt>
<dd><p>Plot the complex in 3D using plotly.</p>
<p>Creates a 3D visualization of the complex, showing all polyhedra as
regions in the input space. Only works for 3D input spaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label_regions</strong> – If True, add text labels showing each polyhedron’s
string representation. Defaults to False.</p></li>
<li><p><strong>color</strong> – If “Wl2”, color polyhedra by their Wl2 (weight norm) value.
If None, use an equitable graph coloring. Defaults to None.</p></li>
<li><p><strong>highlight_regions</strong> – If provided, highlight these polyhedra in red.
Can be a list of Polyhedron objects or their string representations.
Defaults to None.</p></li>
<li><p><strong>show_axes</strong> – If True, display the coordinate axes. Defaults to False.</p></li>
<li><p><strong>project</strong> – If True, also show a projection of the complex onto the
xy plane. Defaults to True.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to each polyhedron’s plot3d() method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A plotly figure containing the 3D plot</dt><dd><p>of the complex.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>plotly.graph_objects.Figure</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.point2poly">
<span class="sig-name descname"><span class="pre">point2poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_exists</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numpy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.point2poly" title="Link to this definition">¶</a></dt>
<dd><p>Convert a data point to its corresponding Polyhedron.</p>
<p>Finds the polyhedron that contains the given data point. Does not add
the polyhedron to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A single data point as a torch.Tensor or np.ndarray.</p></li>
<li><p><strong>check_exists</strong> – If True, return the existing polyhedron from the complex
if it already exists. Defaults to True.</p></li>
<li><p><strong>numpy</strong> – If True, treat input as numpy array. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The polyhedron containing the given point.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.Polyhedron" title="relucent.Polyhedron">Polyhedron</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.point2ss">
<span class="sig-name descname"><span class="pre">point2ss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numpy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.point2ss" title="Link to this definition">¶</a></dt>
<dd><p>Convert a batch of data points to sign sequences.</p>
<p>Computes the combined sign sequence across all ReLU layers for the given
data points. Does not add the resulting polyhedra to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> – A batch of input data points as a torch.Tensor or np.ndarray.</p></li>
<li><p><strong>numpy</strong> – If True, return result as numpy array; otherwise return torch.Tensor.
Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>The sign sequences for</dt><dd><p>the input batch, with shape (batch_size, total_ReLU_neurons).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor or np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.random_walk">
<span class="sig-name descname"><span class="pre">random_walk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.random_walk" title="Link to this definition">¶</a></dt>
<dd><p>Perform random walk search of the complex.</p>
<p>Explores the complex by randomly selecting which polyhedron to explore
next from the queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – All arguments accepted by searcher().</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Search information dictionary (see searcher() documentation).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.recover_from_dual_graph">
<span class="sig-name descname"><span class="pre">recover_from_dual_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.recover_from_dual_graph" title="Link to this definition">¶</a></dt>
<dd><p>Recover a complex from its connectivity graph.</p>
<p>Reconstructs polyhedra in the complex by traversing the adjacency graph
of top-dimensional cells, using the supporting hyperplane indices stored
on edges to determine how to flip sign sequence elements. This is useful
for storing large complexes efficiently, as you only need to store the
graph structure and SHI indices on edges rather than full polyhedron data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – A networkx.Graph representing the dual graph. Edges must have
a “shi” attribute indicating the supporting hyperplane index.</p></li>
<li><p><strong>initial_ss</strong> – The sign sequence of a starting polyhedron
as torch.Tensor or np.ndarray.</p></li>
<li><p><strong>source</strong> – The node key in G representing the initial polyhedron.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>The graph with polyhedron objects stored in node</dt><dd><p>attributes under the “poly” key.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkx.Graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_ssm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.save" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.searcher">
<span class="sig-name descname"><span class="pre">searcher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_polys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">queue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nworkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_volumes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.searcher" title="Link to this definition">¶</a></dt>
<dd><p>Search for polyhedra in the complex by discovering neighbors.</p>
<p>This is a generic search method that can be configured for different
traversal strategies (BFS, DFS, random walk) by providing different
queue types. It starts from a given point and explores the complex by
crossing supporting hyperplanes to discover adjacent polyhedra.</p>
<p>See bfs(), dfs(), and random_walk() for examples of how to use this
function to define specific search strategies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> – Starting point for the search. Can be a torch.Tensor data point
or None (defaults to origin). Defaults to None.</p></li>
<li><p><strong>max_depth</strong> – Maximum search depth (number of hyperplane crossings).
Defaults to infinity.</p></li>
<li><p><strong>max_polys</strong> – Maximum number of polyhedra to discover. Defaults to infinity.</p></li>
<li><p><strong>queue</strong> – Queue object that defines the order in which polyhedra are
searched. Must have push() and pop() methods. If None, uses
BlockingQueue (FIFO). Defaults to None.</p></li>
<li><p><strong>bound</strong> – Constraint radius for numerical stability when computing halfspaces.
Important for numerical stability. Defaults to 1e5.</p></li>
<li><p><strong>nworkers</strong> – Number of worker processes for parallel computation. If None,
uses the number of CPU cores. Defaults to None.</p></li>
<li><p><strong>get_volumes</strong> – Whether to compute volumes for polyhedra when input
dimension &lt;= 6. Defaults to True.</p></li>
<li><p><strong>verbose</strong> – Whether to print progress information. Defaults to 1.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to Polyhedron.get_shis().</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Search information dictionary containing:</dt><dd><ul class="simple">
<li><p>”Search Depth”: Maximum depth reached</p></li>
<li><p>”Avg # Facets Uncorrected”: Average number of facets per polyhedron</p></li>
<li><p>”Search Time”: Elapsed time in seconds</p></li>
<li><p>”Bad SHI Computations”: List of failed computations</p></li>
<li><p>”Complete”: Whether search completed (no unprocessed items)</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the start point lies on a hyperplane (has zero in SS).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.ss2poly">
<span class="sig-name descname"><span class="pre">ss2poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_exists</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.ss2poly" title="Link to this definition">¶</a></dt>
<dd><p>Convert a sign sequence to a Polyhedron.</p>
<p>Creates a Polyhedron object from the given sign sequence. Does not add
it to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ss</strong> – A sign sequence as a torch.Tensor or np.ndarray.</p></li>
<li><p><strong>check_exists</strong> – If True, return the existing polyhedron from the complex
if it already exists. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The polyhedron corresponding to the given sign sequence.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.Polyhedron" title="relucent.Polyhedron">Polyhedron</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.complex.Complex.ss_iterator">
<span class="sig-name descname"><span class="pre">ss_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.Complex.ss_iterator" title="Link to this definition">¶</a></dt>
<dd><p>Generate sign sequences for each ReLU layer from a batch of data points.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>batch</strong> – A batch of input data points as a torch.Tensor or np.ndarray.
Will be reshaped to match the network’s input shape.</p>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><p><em>torch.Tensor</em> –</p>
<dl class="simple">
<dt>Sign sequences for each ReLU layer in</dt><dd><p>the network, indicating the activation pattern of that layer.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.complex.Complex.dim">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">dim</span></span><a class="headerlink" href="#relucent.complex.Complex.dim" title="Link to this definition">¶</a></dt>
<dd><p>The input dimension of the network.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.complex.astar_calculations">
<span class="sig-prename descclassname"><span class="pre">relucent.complex.</span></span><span class="sig-name descname"><span class="pre">astar_calculations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.astar_calculations" title="Link to this definition">¶</a></dt>
<dd><p>Worker function for computing polyhedron properties in A* search.</p>
<p>Similar to poly_calculations, but specifically designed for A* search algorithm.
Computes center, inradius, interior point, and supporting hyperplane indices
for polyhedra during pathfinding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task</strong> – Either a Polyhedron object or a tuple containing (Polyhedron, …)
with additional data to be passed through.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to get_shis() method, such as
‘collect_info’ or ‘bound’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>If successful, returns (Polyhedron, <a href="#id1"><span class="problematic" id="id2">*</span></a>rest). If an exception occurs</dt><dd><p>during SHI computation, returns (Polyhedron, error, <a href="#id3"><span class="problematic" id="id4">*</span></a>rest).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.complex.get_ip">
<span class="sig-prename descclassname"><span class="pre">relucent.complex.</span></span><span class="sig-name descname"><span class="pre">get_ip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.get_ip" title="Link to this definition">¶</a></dt>
<dd><p>Get an interior point for a neighbor polyhedron across a supporting hyperplane.</p>
<p>This function is used by the A* search algorithm to find interior points for
neighboring polyhedra. It flips the element of the sign sequence at the specified
supporting hyperplane index (SHI) and attempts to find an interior point,
increasing the search radius if necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – The source Polyhedron object.</p></li>
<li><p><strong>shi</strong> – The index of the supporting hyperplane to cross.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>If successful, returns (neighbor_polyhedron, shi). If a ValueError</dt><dd><p>occurs, returns (error, None).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.complex.poly_calculations">
<span class="sig-prename descclassname"><span class="pre">relucent.complex.</span></span><span class="sig-name descname"><span class="pre">poly_calculations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.poly_calculations" title="Link to this definition">¶</a></dt>
<dd><p>Worker function for computing polyhedron properties in parallel.</p>
<p>This function is used by parallel_add() and all search methods to compute
halfspaces, center, inradius, interior point, and supporting hyperplane
indices (SHIs) for a given sign sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task</strong> – Either a sign sequence or a tuple containing (sign sequence, …) with
additional data to be passed through.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to get_shis() method, such as
‘collect_info’ or ‘bound’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>If successful, returns (Polyhedron, <a href="#id5"><span class="problematic" id="id6">*</span></a>rest) where rest contains</dt><dd><p>any additional data from the input task. If a ValueError occurs
during computation, returns (error, <a href="#id7"><span class="problematic" id="id8">*</span></a>rest).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.complex.set_globals">
<span class="sig-prename descclassname"><span class="pre">relucent.complex.</span></span><span class="sig-name descname"><span class="pre">set_globals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">get_net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_volumes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.complex.set_globals" title="Link to this definition">¶</a></dt>
<dd><p>Initialize global variables for worker processes in multiprocessing.</p>
<p>This function should only be used as an initializer for multiprocessing pools,
never called directly by the main process. It sets up the network, environment,
and volume calculation settings that worker processes need.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>get_net</strong> – The neural network object to be used by worker processes.</p></li>
<li><p><strong>get_volumes</strong> – Whether to compute volumes for polyhedra when input dimension &lt;= 6.
Defaults to True.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">nworkers</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">set_globals</span><span class="p">,</span> <span class="n">initargs</span><span class="o">=</span><span class="p">(</span><span class="n">net</span><span class="p">,))</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
<span class="gp">... </span>    <span class="c1"># Use pool for parallel processing</span>
<span class="gp">... </span>    <span class="k">pass</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-relucent.convert_model">
<span id="relucent-convert-model-module"></span><h2>relucent.convert_model module<a class="headerlink" href="#module-relucent.convert_model" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="relucent.convert_model.avgpool2d_to_affine">
<span class="sig-prename descclassname"><span class="pre">relucent.convert_model.</span></span><span class="sig-name descname"><span class="pre">avgpool2d_to_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">avgpool</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">AvgPool2d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Linear</span></span></span><a class="headerlink" href="#relucent.convert_model.avgpool2d_to_affine" title="Link to this definition">¶</a></dt>
<dd><p>Convert an AvgPool2d layer to an equivalent Linear layer.</p>
<p>Converts average pooling into a fully connected layer by representing it
as a convolution with uniform weights, then converting that to a Linear layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>avgpool</strong> – The AvgPool2d layer to convert.</p></li>
<li><p><strong>input_size</strong> – Input size as (channels, height, width) tuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Linear layer that performs the equivalent operation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nn.Linear</p>
</dd>
</dl>
<dl class="simple">
<dt>Reference:</dt><dd><p>Based on: <a class="reference external" href="https://www.researchgate.net/figure/The-mean-pooling-is-described-with-the-matrix-multiplication-of-the-reshaped-feature-map_fig2_357833254">https://www.researchgate.net/figure/The-mean-pooling-is-described-with-the-matrix-multiplication-of-the-reshaped-feature-map_fig2_357833254</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.convert_model.combine_linear_layers">
<span class="sig-prename descclassname"><span class="pre">relucent.convert_model.</span></span><span class="sig-name descname"><span class="pre">combine_linear_layers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old_layers</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.convert_model.combine_linear_layers" title="Link to this definition">¶</a></dt>
<dd><p>Combine consecutive Linear layers into a single layer.</p>
<p>Since the composition of two linear transformations is itself linear,
multiple consecutive Linear layers can be combined into one for efficiency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>old_layers</strong> – OrderedDict of layers to process.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>New dictionary with consecutive Linear layers combined.</dt><dd><p>Layer names are concatenated with ‘+’ for combined layers.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>OrderedDict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.convert_model.convert">
<span class="sig-prename descclassname"><span class="pre">relucent.convert_model.</span></span><span class="sig-name descname"><span class="pre">convert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Module</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Module</span></span></span><a class="headerlink" href="#relucent.convert_model.convert" title="Link to this definition">¶</a></dt>
<dd><p>Convert a PyTorch model to canonical NN format.</p>
<p>Converts various PyTorch layer types (Conv2d, AvgPool2d, etc.) into the
canonical format consisting only of Linear and ReLU layers.</p>
<dl class="simple">
<dt>Supported layer types:</dt><dd><ul class="simple">
<li><p>Linear, ReLU: Passed through unchanged</p></li>
<li><p>Conv2d: Converted to Linear</p></li>
<li><p>AvgPool2d: Converted to Linear (if kernel_size == stride)</p></li>
<li><p>Flatten: Handled automatically</p></li>
<li><p>Dropout: Removed (not needed for inference)</p></li>
<li><p>LogSoftmax: Stops conversion (output layer)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>model</strong> – A PyTorch nn.Module with an ‘input_shape’ attribute and ‘layers’
attribute containing an OrderedDict of layers.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new NN object in canonical format.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.NN" title="relucent.NN">NN</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If an unsupported layer type is encountered.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.convert_model.flatten_to_affine">
<span class="sig-prename descclassname"><span class="pre">relucent.convert_model.</span></span><span class="sig-name descname"><span class="pre">flatten_to_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Linear</span></span></span><a class="headerlink" href="#relucent.convert_model.flatten_to_affine" title="Link to this definition">¶</a></dt>
<dd><p>Convert a Flatten operation to an identity Linear layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_size</strong> – Input size as (channels, height, width) tuple.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An identity Linear layer.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nn.Linear</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.convert_model.torch_conv_layer_to_affine">
<span class="sig-prename descclassname"><span class="pre">relucent.convert_model.</span></span><span class="sig-name descname"><span class="pre">torch_conv_layer_to_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Conv2d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Linear</span></span></span><a class="headerlink" href="#relucent.convert_model.torch_conv_layer_to_affine" title="Link to this definition">¶</a></dt>
<dd><p>Convert a Conv2d layer to an equivalent Linear layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conv</strong> – The Conv2d layer to convert.</p></li>
<li><p><strong>input_size</strong> – Input size as (channels, height, width) tuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Linear layer that performs the equivalent operation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nn.Linear</p>
</dd>
</dl>
<dl class="simple">
<dt>Reference:</dt><dd><p>Based on: <a class="reference external" href="https://gist.github.com/vvolhejn/e265665c65d3df37e381316bf57b8421">https://gist.github.com/vvolhejn/e265665c65d3df37e381316bf57b8421</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-relucent.model">
<span id="relucent-model-module"></span><h2>relucent.model module<a class="headerlink" href="#module-relucent.model" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="relucent.model.NN">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">relucent.model.</span></span><span class="sig-name descname"><span class="pre">NN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.model.NN" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Neural network class that interfaces with the rest of the package</p>
<dl class="py method">
<dt class="sig sig-object py" id="relucent.model.NN.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.model.NN.forward" title="Link to this definition">¶</a></dt>
<dd><p>Define the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.model.NN.get_all_layer_outputs">
<span class="sig-name descname"><span class="pre">get_all_layer_outputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.model.NN.get_all_layer_outputs" title="Link to this definition">¶</a></dt>
<dd><p>Get outputs from specified layers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – Input tensor to the network.</p></li>
<li><p><strong>layers</strong> – List of layer names to include. If None, includes all layers.
Defaults to None.</p></li>
<li><p><strong>verbose</strong> – If True, prints layer information. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dictionary mapping layer names to their outputs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>OrderedDict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.model.NN.get_grid">
<span class="sig-name descname"><span class="pre">get_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.model.NN.get_grid" title="Link to this definition">¶</a></dt>
<dd><p>Generate a 2D grid of input points.</p>
<p>Creates a regular grid of points in 2D space. Only works for 2D input spaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> – Half-width of the grid (grid spans [-bounds, bounds]).
Defaults to 2.</p></li>
<li><p><strong>res</strong> – Resolution (number of points per dimension). Defaults to 100.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(x_coords, y_coords, input_points) where input_points is an</dt><dd><p>array of shape (res*res, 2).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.model.NN.output_grid">
<span class="sig-name descname"><span class="pre">output_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.model.NN.output_grid" title="Link to this definition">¶</a></dt>
<dd><p>Generate a grid and compute network outputs for all points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> – Half-width of the grid. Defaults to 2.</p></li>
<li><p><strong>res</strong> – Resolution (number of points per dimension). Defaults to 100.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(x_coords, y_coords, layer_outputs) where layer_outputs is</dt><dd><p>an OrderedDict mapping layer names to outputs.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.model.NN.shi2weights">
<span class="sig-name descname"><span class="pre">shi2weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.model.NN.shi2weights" title="Link to this definition">¶</a></dt>
<dd><p>Get weights corresponding to a neuron index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shi</strong> – Index of the neuron (supporting hyperplane index).</p></li>
<li><p><strong>return_idx</strong> – If True, returns (layer_name, neuron_index_in_layer).
If False, returns a pointer to the weight tensor. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor weight vector.
If return_idx is True: (layer_name, neuron_index) tuple.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>If return_idx is False</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the neuron index is invalid.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.model.NN.device">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">device</span></span><a class="headerlink" href="#relucent.model.NN.device" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.model.NN.dtype">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#relucent.model.NN.dtype" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.model.NN.num_relus">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">num_relus</span></span><a class="headerlink" href="#relucent.model.NN.num_relus" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.model.get_mlp_model">
<span class="sig-prename descclassname"><span class="pre">relucent.model.</span></span><span class="sig-name descname"><span class="pre">get_mlp_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">widths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_last_relu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.model.get_mlp_model" title="Link to this definition">¶</a></dt>
<dd><p>Create an NN object for a multi-layer perceptron (MLP).</p>
<p>Constructs a fully connected neural network with the specified layer widths.
Each layer (except optionally the last) is followed by a ReLU activation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>widths</strong> – List of integers specifying the number of neurons in each layer,
including the input layer. For example, [2, 10, 5, 1] creates a
network with input dimension 2, two hidden layers with 10 and 5 neurons,
and output dimension 1.</p></li>
<li><p><strong>add_last_relu</strong> – If True, adds a ReLU after the last layer. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A configured neural network object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.model.NN" title="relucent.model.NN">NN</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-relucent.poly">
<span id="relucent-poly-module"></span><h2>relucent.poly module<a class="headerlink" href="#module-relucent.poly" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">relucent.poly.</span></span><span class="sig-name descname"><span class="pre">Polyhedron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">halfspaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a polyhedron (linear region) in d-dimensional space.</p>
<p>Several methods use Gurobi environments for optimization. If one is not
provided, an environment will be created automatically.</p>
<dl class="py method">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.clean_data">
<span class="sig-name descname"><span class="pre">clean_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron.clean_data" title="Link to this definition">¶</a></dt>
<dd><p>Clear cached data to reduce memory usage.</p>
<p>Removes large cached properties like halfspaces, W matrix, center,
and halfspace intersection data. Keeps small properties, the sign sequence,
and the interior point.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.compute_properties">
<span class="sig-name descname"><span class="pre">compute_properties</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron.compute_properties" title="Link to this definition">¶</a></dt>
<dd><p>Compute additional geometric properties for low-dimensional polyhedra.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if computation succeeded.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If input dimension &gt; 6 or if computation fails.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.get_bounded_halfspaces">
<span class="sig-name descname"><span class="pre">get_bounded_halfspaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron.get_bounded_halfspaces" title="Link to this definition">¶</a></dt>
<dd><p>Get halfspaces after adding bounding box constraints.</p>
<p>Adds constraints that bound the space to a hypercube of radius ‘bound’
around the origin. Useful for plotting and visualization. Returns None
if the polyhedron doesn’t intersect the bounded region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bound</strong> – Radius of the bounding hypercube.</p></li>
<li><p><strong>env</strong> – Gurobi environment for feasibility checking. If None, uses
a cached environment. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Halfspaces with bounding constraints added, or</dt><dd><p>None if the polyhedron doesn’t intersect the bounded region.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.get_bounded_vertices">
<span class="sig-name descname"><span class="pre">get_bounded_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bound</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron.get_bounded_vertices" title="Link to this definition">¶</a></dt>
<dd><p>Get the vertices of the polyhedron within a bounding hypercube.</p>
<p>Computes the vertices of the polyhedron after intersecting it with a
hypercube of radius ‘bound’. Primarily used for plotting and visualization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bound</strong> – Radius of the bounding hypercube.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Array of vertex coordinates, or None if the</dt><dd><p>polyhedron doesn’t intersect the bounded region or computation fails.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.get_center_inradius">
<span class="sig-name descname"><span class="pre">get_center_inradius</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron.get_center_inradius" title="Link to this definition">¶</a></dt>
<dd><p>Get the Chebyshev center and inradius of the polyhedron.</p>
<p>Also sets self._finite to indicate if the polyhedron is finite.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>env</strong> – Gurobi environment for optimization. If None, uses a cached
environment. Defaults to None.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(center, inradius) where center is None for unbounded polyhedra.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.get_hs">
<span class="sig-name descname"><span class="pre">get_hs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_all_Ab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron.get_hs" title="Link to this definition">¶</a></dt>
<dd><p>Get the halfspace representation of this polyhedron.</p>
<p>Computes the halfspaces (inequality constraints) that define the polyhedron
from all neurons in the network. The result includes constraints from
every neuron, not just the supporting hyperplanes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – Optional input data to the network for verification. If provided,
checks that computed outputs match network outputs. Defaults to None.</p></li>
<li><p><strong>get_all_Ab</strong> – If True, returns all intermediate affine maps (A, b) for
each layer instead of just the final halfspaces. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(halfspaces, W, b) where:</dt><dd><ul class="simple">
<li><p>halfspaces: Array of shape (n_constraints, n_dim+1) with bias terms</p></li>
<li><p>W: Affine transformation matrix</p></li>
<li><p>b: Affine transformation bias vector</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.get_interior_point">
<span class="sig-name descname"><span class="pre">get_interior_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron.get_interior_point" title="Link to this definition">¶</a></dt>
<dd><p>Get a point inside the polyhedron.</p>
<p>Computes an interior point of the polyhedron. If the center is already
computed, uses that; otherwise solves for an interior point using Gurobi.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>env</strong> – Gurobi environment for optimization. If None, uses a cached
environment. Defaults to None.</p></li>
<li><p><strong>max_radius</strong> – Maximum radius constraint for the search. If None, uses
self.MAX_RADIUS. Defaults to None.</p></li>
<li><p><strong>zero_indices</strong> – Indices of sign sequence elements that are zero (for
lower-dimensional polyhedra). Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An interior point of the polyhedron.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If no interior point can be found.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.get_shis">
<span class="sig-name descname"><span class="pre">get_shis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">collect_info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e+100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shi_pbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron.get_shis" title="Link to this definition">¶</a></dt>
<dd><p>Get supporting halfspace indices (SHIs) for this polyhedron.</p>
<p>Computes the indices of non-redundant halfspaces that form the boundary
of this polyhedron. These correspond to neurons whose boundaries (BHs)
are actually part of the polyhedron’s boundary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collect_info</strong> – If True, collects additional debugging information
about the computations. If “All”, collects even more detailed info.
Defaults to False.</p></li>
<li><p><strong>bound</strong> – Defines the hypercube bounding the space for numerical stability.
Defaults to infinity.</p></li>
<li><p><strong>subset</strong> – Indices of neurons/halfspaces to consider. If None, considers
all halfspaces. Defaults to None.</p></li>
<li><p><strong>tol</strong> – Inequality tolerance to improve numerical stability. Defaults to 1e-6.</p></li>
<li><p><strong>new_method</strong> – If True, uses an extra computation that doesn’t improve
runtime. Defaults to False.</p></li>
<li><p><strong>env</strong> – Gurobi environment for optimization. If None, uses a cached
environment. Defaults to None.</p></li>
<li><p><strong>shi_pbar</strong> – If True, shows a progress bar during computation. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>If collect_info is False, returns a list of SHI indices.</dt><dd><p>If collect_info is True, returns (shis, info) where info is a list
of dictionaries with computation details.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list or tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the optimization model fails.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.is_face_of">
<span class="sig-name descname"><span class="pre">is_face_of</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron.is_face_of" title="Link to this definition">¶</a></dt>
<dd><p>Check if this polyhedron is a face of another polyhedron.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – Another Polyhedron object to check against.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if this polyhedron is a face of the other.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.nflips">
<span class="sig-name descname"><span class="pre">nflips</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron.nflips" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the number of non-zero sign sequence elements that differ.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – Another Polyhedron object to compare with.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of sign sequence elements that differ.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.plot2d">
<span class="sig-name descname"><span class="pre">plot2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'toself'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">showlegend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron.plot2d" title="Link to this definition">¶</a></dt>
<dd><p>Plot the polyhedron in 2D using plotly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fill</strong> – Fill mode passed to go.Scatter. Defaults to “toself”.</p></li>
<li><p><strong>showlegend</strong> – Whether to show in legend. Defaults to False.</p></li>
<li><p><strong>bound</strong> – Radius of the bounding hypercube for vertex computation.
Defaults to 1000.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to go.Scatter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A plotly Scatter trace, or None</dt><dd><p>if plotting fails.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>plotly.graph_objects.Scatter or None</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the polyhedron is not 2D.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.plot3d">
<span class="sig-name descname"><span class="pre">plot3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'toself'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">showlegend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.Polyhedron.plot3d" title="Link to this definition">¶</a></dt>
<dd><p>Plot the polyhedron in 3D using plotly.</p>
<p>Creates a 3D mesh plot of the polyhedron. The z-coordinates are computed
by passing the 2D vertices through the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fill</strong> – Fill mode (not used for 3D plots). Defaults to “toself”.</p></li>
<li><p><strong>showlegend</strong> – Whether to show in legend. Defaults to False.</p></li>
<li><p><strong>bound</strong> – Radius of the bounding hypercube for vertex computation.
Defaults to 1000.</p></li>
<li><p><strong>project</strong> – If a number, projects the polyhedron onto this z-value
instead of computing it from the network. Defaults to None.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to go.Mesh3d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Dictionary with ‘mesh’ and ‘outline’ keys containing</dt><dd><p>plotly traces, or None if plotting fails.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict or None</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the polyhedron is not 2D.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.MAX_RADIUS">
<span class="sig-name descname"><span class="pre">MAX_RADIUS</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">100</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.MAX_RADIUS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.W">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">W</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.W" title="Link to this definition">¶</a></dt>
<dd><p>Affine transformation matrix W such that the polyhedron maps to W*x + b.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Transformation matrix.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor or np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.Wl2">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">Wl2</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.Wl2" title="Link to this definition">¶</a></dt>
<dd><p>L2 norm of the transformation matrix W.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.b">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">b</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.b" title="Link to this definition">¶</a></dt>
<dd><p>Affine transformation bias vector such that the polyhedron maps to W*x + b.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Bias vector.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor or np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.center">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">center</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.center" title="Link to this definition">¶</a></dt>
<dd><p>Chebyshev center of the polyhedron for finite polyhedra, or None for unbounded polyhedra.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.ch">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">ch</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.ch" title="Link to this definition">¶</a></dt>
<dd><p>Convex hull of the polyhedron for finite polyhedra.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.finite">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">finite</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.finite" title="Link to this definition">¶</a></dt>
<dd><p>Whether the polyhedron is bounded (finite).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.halfspaces">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">halfspaces</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.halfspaces" title="Link to this definition">¶</a></dt>
<dd><p>Halfspace representation of the polyhedron.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>Array of shape (n_constraints, n_dim+1)</dt><dd><p>where each row is [a1, a2, …, ad, b] representing the
constraint a^T x + b &lt;= 0.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor or np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.hs">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">hs</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.hs" title="Link to this definition">¶</a></dt>
<dd><p>Halfspace intersection object from scipy.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.inradius">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">inradius</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.inradius" title="Link to this definition">¶</a></dt>
<dd><p>Inradius of the polyhedron (radius of largest inscribed ball), infinity for unbounded polyhedra.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.interior_point">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">interior_point</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.interior_point" title="Link to this definition">¶</a></dt>
<dd><p>A point guaranteed to be inside the polyhedron.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.interior_point_norm">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">interior_point_norm</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.interior_point_norm" title="Link to this definition">¶</a></dt>
<dd><p>L2 norm of the interior point.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.num_dead_relus">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">num_dead_relus</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.num_dead_relus" title="Link to this definition">¶</a></dt>
<dd><p>Number of dead ReLU neurons (neurons always outputting zero).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Count of ReLU neurons that are always inactive for this polyhedron.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.num_faces">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">num_faces</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.num_faces" title="Link to this definition">¶</a></dt>
<dd><p>Alias for Polyhedron.num_shis</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.num_shis">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">num_shis</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.num_shis" title="Link to this definition">¶</a></dt>
<dd><p>Number of faces.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.point">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">point</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.point" title="Link to this definition">¶</a></dt>
<dd><p>The center if available, otherwise an interior point.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.shis">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">shis</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.shis" title="Link to this definition">¶</a></dt>
<dd><p>Supporting halfspace indices (SHIs).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.tag">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">tag</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.tag" title="Link to this definition">¶</a></dt>
<dd><p>Unique tag for this polyhedron, computed as a hashable
representation of the sign sequence.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.vertex_set">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">vertex_set</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.vertex_set" title="Link to this definition">¶</a></dt>
<dd><p>Set of vertices of the polyhedron (not always reliable).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.vertices">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">vertices</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.vertices" title="Link to this definition">¶</a></dt>
<dd><p>Vertices of the polyhedron (not always reliable).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Array of vertex coordinates.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.poly.Polyhedron.volume">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">volume</span></span><a class="headerlink" href="#relucent.poly.Polyhedron.volume" title="Link to this definition">¶</a></dt>
<dd><p>Volume of the polyhedron, infinity for unbounded polyhedra,
or -1 if computation fails.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.poly.encode_ss">
<span class="sig-prename descclassname"><span class="pre">relucent.poly.</span></span><span class="sig-name descname"><span class="pre">encode_ss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ss</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.encode_ss" title="Link to this definition">¶</a></dt>
<dd><p>Create a hashable representation of a sign sequence.</p>
<p>Converts a sign sequence array into a bytes object that can be used as a
dictionary key or for hashing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ss</strong> – A sign sequence as np.ndarray or torch.Tensor with values in {-1, 0, 1}.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A hashable bytes representation of the flattened sign sequence.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.poly.solve_radius">
<span class="sig-prename descclassname"><span class="pre">relucent.poly.</span></span><span class="sig-name descname"><span class="pre">solve_radius</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">env</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">halfspaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e+100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.poly.solve_radius" title="Link to this definition">¶</a></dt>
<dd><p>Solve for the Chebyshev center or interior point of a polyhedron.</p>
<p>Only works if all polyhedron vertices are within 2*max_radius of each other.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>env</strong> – Gurobi environment for optimization.</p></li>
<li><p><strong>halfspaces</strong> – Halfspace representation of the polyhedron as an array with
shape (n_constraints, n_dim+1), where the last column contains bias terms.</p></li>
<li><p><strong>max_radius</strong> – Maximum radius constraint for the polyhedron. Defaults to infinity.</p></li>
<li><p><strong>zero_indices</strong> – Indices of sign sequence elements that are zero (for
lower-dimensional polyhedra). Defaults to None.</p></li>
<li><p><strong>sense</strong> – Optimization sense, should typically be GRB.MAXIMIZE. Defaults to GRB.MAXIMIZE.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(center_point, radius) where center_point is the center/interior</dt><dd><p>point and radius is the inradius. Returns (None, None) if the polyhedron
is unbounded and max_radius is infinity.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the optimization fails or produces invalid results.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-relucent.ss">
<span id="relucent-ss-module"></span><h2>relucent.ss module<a class="headerlink" href="#module-relucent.ss" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="relucent.ss.SSManager">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">relucent.ss.</span></span><span class="sig-name descname"><span class="pre">SSManager</span></span><a class="headerlink" href="#relucent.ss.SSManager" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Manages storage and lookup of sign sequences.</p>
<p>This class provides a dictionary-like interface for storing and retrieving
sign sequences (arrays with values in {-1, 0, 1}). It maintains an index
mapping and allows efficient membership testing and retrieval.</p>
<p>Sign sequences are encoded as hashable tags for efficient storage and lookup.</p>
<dl class="py method">
<dt class="sig sig-object py" id="relucent.ss.SSManager.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ss</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.ss.SSManager.add" title="Link to this definition">¶</a></dt>
<dd><p>Add a sign sequence to the manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ss</strong> – A sign sequence as torch.Tensor or np.ndarray.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="relucent.ss.SSPriorityQueue">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">relucent.ss.</span></span><span class="sig-name descname"><span class="pre">SSPriorityQueue</span></span><a class="headerlink" href="#relucent.ss.SSPriorityQueue" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Priority queue for tasks with sign sequences.</p>
<p>A priority queue implementation that supports updating task priorities and
removing tasks. Tasks are tuples starting with a sign sequence followed
by additional data. Based on the heapq implementation from Python docs.</p>
<p>Reference: <a class="reference external" href="https://docs.python.org/3/library/heapq.html">https://docs.python.org/3/library/heapq.html</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="relucent.ss.SSPriorityQueue.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.ss.SSPriorityQueue.pop" title="Link to this definition">¶</a></dt>
<dd><p>Remove and return the lowest priority task.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A tuple starting with the sign sequence followed by</dt><dd><p>the task data.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>KeyError</strong> – If the queue is empty.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.ss.SSPriorityQueue.push">
<span class="sig-name descname"><span class="pre">push</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priority</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.ss.SSPriorityQueue.push" title="Link to this definition">¶</a></dt>
<dd><p>Add a new task or update the priority of an existing task.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task</strong> – A tuple starting with a sign sequence followed by
additional task data.</p></li>
<li><p><strong>priority</strong> – The priority value (lower = higher priority). Defaults to 0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.ss.SSPriorityQueue.remove_task">
<span class="sig-name descname"><span class="pre">remove_task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.ss.SSPriorityQueue.remove_task" title="Link to this definition">¶</a></dt>
<dd><p>Mark an existing task as REMOVED.  Raise KeyError if not found.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="relucent.ss.SSPriorityQueue.REMOVED">
<span class="sig-name descname"><span class="pre">REMOVED</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'&lt;removed-task&gt;'</span></span><a class="headerlink" href="#relucent.ss.SSPriorityQueue.REMOVED" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-relucent.utils">
<span id="relucent-utils-module"></span><h2>relucent.utils module<a class="headerlink" href="#module-relucent.utils" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="relucent.utils.BlockingQueue">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">relucent.utils.</span></span><span class="sig-name descname"><span class="pre">BlockingQueue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">queue_class</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&lt;class</span> <span class="pre">'collections.deque'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&lt;function</span> <span class="pre">BlockingQueue.&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">push</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&lt;function</span> <span class="pre">BlockingQueue.&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.BlockingQueue" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Queue that patiently waits for new elements if you pop() while it’s empty</p>
<dl class="py method">
<dt class="sig sig-object py" id="relucent.utils.BlockingQueue.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.BlockingQueue.close" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.utils.BlockingQueue.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.BlockingQueue.pop" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.utils.BlockingQueue.push">
<span class="sig-name descname"><span class="pre">push</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.BlockingQueue.push" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="relucent.utils.BlockingQueue.stopFlag">
<span class="sig-name descname"><span class="pre">stopFlag</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'&lt;stop&gt;'</span></span><a class="headerlink" href="#relucent.utils.BlockingQueue.stopFlag" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="relucent.utils.NonBlockingQueue">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">relucent.utils.</span></span><span class="sig-name descname"><span class="pre">NonBlockingQueue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">queue_class</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&lt;class</span> <span class="pre">'collections.deque'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&lt;function</span> <span class="pre">NonBlockingQueue.&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">push</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&lt;function</span> <span class="pre">NonBlockingQueue.&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.NonBlockingQueue" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Just a normal queue</p>
<dl class="py method">
<dt class="sig sig-object py" id="relucent.utils.NonBlockingQueue.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.NonBlockingQueue.close" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.utils.NonBlockingQueue.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.NonBlockingQueue.pop" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.utils.NonBlockingQueue.push">
<span class="sig-name descname"><span class="pre">push</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.NonBlockingQueue.push" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="relucent.utils.NonBlockingQueue.stopFlag">
<span class="sig-name descname"><span class="pre">stopFlag</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'&lt;stop&gt;'</span></span><a class="headerlink" href="#relucent.utils.NonBlockingQueue.stopFlag" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.utils.data_graph">
<span class="sig-prename descclassname"><span class="pre">relucent.utils.</span></span><span class="sig-name descname"><span class="pre">data_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">draw_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_title_formatter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_label_formatter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_size_formatter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_title_formatter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_label_formatter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_value_formatter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_images</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_num_examples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./graph.html'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.data_graph" title="Link to this definition">¶</a></dt>
<dd><p>Create an interactive pyvis graph from dataframes of nodes and edges.</p>
<p>Creates a visual graph representation where nodes can contain images of
data examples. Useful for visualizing relationships in datasets or
polyhedral complexes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_df</strong> – DataFrame with node information. Each row should have ‘data’
(list of examples) and optionally ‘title’, ‘label’, ‘size’, etc.</p></li>
<li><p><strong>edge_df</strong> – DataFrame with edge information. Index should be (node1, node2)
tuples, and rows can have ‘title’, ‘label’, ‘value’, etc.</p></li>
<li><p><strong>dataset</strong> – Optional dataset object for extracting class labels. Defaults to None.</p></li>
<li><p><strong>draw_function</strong> – Function to draw individual data examples. Should accept
‘data’ and ‘ax’ parameters. Defaults to None.</p></li>
<li><p><strong>class_labels</strong> – If True and dataset is provided, shows class proportions
as pie charts. Defaults to True.</p></li>
<li><p><strong>node_title_formatter</strong> – Function to format node titles. Defaults to using
‘title’ column or string representation.</p></li>
<li><p><strong>node_label_formatter</strong> – Function to format node labels. Defaults to using
‘label’ column or index.</p></li>
<li><p><strong>node_size_formatter</strong> – Function to determine node sizes. Defaults to using
‘size’ column or 10.</p></li>
<li><p><strong>edge_title_formatter</strong> – Function to format edge titles. Defaults to using
‘title’ column or empty string.</p></li>
<li><p><strong>edge_label_formatter</strong> – Function to format edge labels. Defaults to using
‘label’ column or empty string.</p></li>
<li><p><strong>edge_value_formatter</strong> – Function to determine edge values/weights.
Defaults to using ‘value’ column or 1.</p></li>
<li><p><strong>max_images</strong> – Maximum number of node images to generate. Defaults to 3000.</p></li>
<li><p><strong>max_num_examples</strong> – Maximum number of data examples to show per node.
Defaults to 3.</p></li>
<li><p><strong>save_file</strong> – Path to save the HTML graph file. Defaults to “./graph.html”.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.utils.get_colors">
<span class="sig-prename descclassname"><span class="pre">relucent.utils.</span></span><span class="sig-name descname"><span class="pre">get_colors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'viridis'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.get_colors" title="Link to this definition">¶</a></dt>
<dd><p>Map some numbers to some colors</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.utils.get_env">
<span class="sig-prename descclassname"><span class="pre">relucent.utils.</span></span><span class="sig-name descname"><span class="pre">get_env</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.get_env" title="Link to this definition">¶</a></dt>
<dd><p>Get a cached Gurobi environment.</p>
<p>Creates and caches a Gurobi environment with logging disabled. This avoids
the overhead of creating multiple environments. For more control over the
environment, create and pass one directly to functions that need it.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A Gurobi environment with logging disabled.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>gurobipy.Env</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.utils.set_seeds">
<span class="sig-prename descclassname"><span class="pre">relucent.utils.</span></span><span class="sig-name descname"><span class="pre">set_seeds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.set_seeds" title="Link to this definition">¶</a></dt>
<dd><p>Set all RNG seeds to a given value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>seed</strong> – Integer seed value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.utils.split_sequential">
<span class="sig-prename descclassname"><span class="pre">relucent.utils.</span></span><span class="sig-name descname"><span class="pre">split_sequential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_layer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.utils.split_sequential" title="Link to this definition">¶</a></dt>
<dd><p>Split a neural network into two sequential parts.</p>
<p>Creates two separate NN objects by splitting the model at a specified layer.
The first network contains layers up to and including split_layer, and the
second contains all subsequent layers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – The NN object to split.</p></li>
<li><p><strong>split_layer</strong> – Name of the layer at which to split (this layer goes to
the first network).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(nn1, nn2) where nn1 contains layers up to split_layer and</dt><dd><p>nn2 contains the remaining layers.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-relucent">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-relucent" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="relucent.Complex">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">relucent.</span></span><span class="sig-name descname"><span class="pre">Complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Manages the polyhedral complex of a neural network.</p>
<p>This class provides methods for calculating, storing, and searching the h-representations
(halfspace representations) of polyhedra in the complex.</p>
<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.add_point">
<span class="sig-name descname"><span class="pre">add_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numpy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.add_point" title="Link to this definition">¶</a></dt>
<dd><p>Find the polyhedron containing a data point and add it to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – A single data point as a torch.Tensor or np.ndarray.</p></li>
<li><p><strong>numpy</strong> – If True, treat input as numpy array. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The polyhedron containing the given point, now stored in the complex.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.Polyhedron" title="relucent.Polyhedron">Polyhedron</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.add_polyhedron">
<span class="sig-name descname"><span class="pre">add_polyhedron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.add_polyhedron" title="Link to this definition">¶</a></dt>
<dd><p>Add a Polyhedron to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – The Polyhedron object to add.</p></li>
<li><p><strong>overwrite</strong> – If True and the polyhedron already exists, replace it with
the new one. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The polyhedron that was added (or already existed) in the complex.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.Polyhedron" title="relucent.Polyhedron">Polyhedron</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.add_ss">
<span class="sig-name descname"><span class="pre">add_ss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_exists</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.add_ss" title="Link to this definition">¶</a></dt>
<dd><p>Convert a sign sequence to a Polyhedron and add it to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ss</strong> – A sign sequence as a torch.Tensor or np.ndarray.</p></li>
<li><p><strong>check_exists</strong> – If True, return the existing polyhedron from the complex
if it already exists. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The polyhedron that was added (or already existed) in the complex.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.Polyhedron" title="relucent.Polyhedron">Polyhedron</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.adjacent_polyhedra">
<span class="sig-name descname"><span class="pre">adjacent_polyhedra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.adjacent_polyhedra" title="Link to this definition">¶</a></dt>
<dd><p>Get the Polyhedra that are adjacent (across one BH) from the given Polyhedron.</p>
<p>Also works on lower-dimensional polyhedra.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.bfs">
<span class="sig-name descname"><span class="pre">bfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.bfs" title="Link to this definition">¶</a></dt>
<dd><p>Perform breadth-first search of the complex.</p>
<p>Explores the complex using a breadth-first strategy, discovering all
polyhedra at depth d before moving to depth d+1. Uses a FIFO queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – All arguments accepted by searcher().</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Search information dictionary (see searcher() documentation).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.clean_data">
<span class="sig-name descname"><span class="pre">clean_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.clean_data" title="Link to this definition">¶</a></dt>
<dd><p>Clean cached data from all polyhedra in the complex.</p>
<p>This method calls clean_data() on each polyhedron, which removes most of their
computed data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.dfs">
<span class="sig-name descname"><span class="pre">dfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.dfs" title="Link to this definition">¶</a></dt>
<dd><p>Perform depth-first search of the complex.</p>
<p>Explores the complex using a depth-first strategy, following paths as
deeply as possible before backtracking. Uses a LIFO queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – All arguments accepted by searcher().</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Search information dictionary (see searcher() documentation).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.get_dual_graph">
<span class="sig-name descname"><span class="pre">get_dual_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">relabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'viridis'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_locations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.get_dual_graph" title="Link to this definition">¶</a></dt>
<dd><p>Construct the dual graph of the complex.</p>
<p>The dual graph represents the connectivity structure of the complex,
where nodes are polyhedra and edges connect adjacent polyhedra (those
sharing a supporting hyperplane).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>relabel</strong> – If True, nodes are indexed by integers matching self.index2poly
indices. If False, nodes are Polyhedron objects. Defaults to False.</p></li>
<li><p><strong>plot</strong> – If True, prepare the graph for visualization with pyvis by
adding layout and styling attributes. Defaults to False.</p></li>
<li><p><strong>node_color</strong> – If “Wl2”, color nodes by their Wl2 (weight norm) value.
If “volume”, color by volume. If None, no special coloring.
Defaults to None.</p></li>
<li><p><strong>node_size</strong> – If “volume”, size nodes proportionally to their volume.
If None, use default size. Defaults to None.</p></li>
<li><p><strong>cmap</strong> – Colormap to use when node_color is specified. Defaults to “viridis”.</p></li>
<li><p><strong>match_locations</strong> – If True, position graph nodes at the center points
of their polyhedra (only works for 2D complexes). Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>The dual graph of the complex. Nodes are polyhedra</dt><dd><p>(or integers if relabel=True), edges connect adjacent polyhedra
and have a “shi” attribute indicating which supporting hyperplane
they cross.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkx.Graph</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If match_locations is True and the complex is not 2D.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.get_poly_attrs">
<span class="sig-name descname"><span class="pre">get_poly_attrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.get_poly_attrs" title="Link to this definition">¶</a></dt>
<dd><p>Extract specified attributes from all polyhedra in the complex.</p>
<p>Useful for building tabular representations or dataframes of polyhedra
properties. Attributes are returned in the same order as polyhedra were
added to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>attrs</strong> – A list of attribute names to extract (e.g., [“finite”, “Wl2”]).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A dictionary mapping attribute names to lists of attribute</dt><dd><p>values, with one value per polyhedron in the complex based on the order
they were added.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.greedy_path">
<span class="sig-name descname"><span class="pre">greedy_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.greedy_path" title="Link to this definition">¶</a></dt>
<dd><p>Greedily find a path between two data points.</p>
<p>Attempts to find a path through adjacent polyhedra from start to end
using a greedy strategy. This method can be slow for large complexes
as it explores many paths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> – Starting data point as torch.Tensor or np.ndarray.</p></li>
<li><p><strong>end</strong> – Ending data point as torch.Tensor or np.ndarray.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A list of Polyhedron objects representing the path</dt><dd><p>from start to end, or None if no path is found.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.hamming_astar">
<span class="sig-name descname"><span class="pre">hamming_astar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nworkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_polys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_pbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.hamming_astar" title="Link to this definition">¶</a></dt>
<dd><p>Find a path between two data points using A* search algorithm.</p>
<p>Uses the A* pathfinding algorithm with a heuristic based on Hamming
distance between sign sequences, plus Euclidean distance between interior
points to break ties. The heuristic should be admissible for optimal paths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> – Starting data point as torch.Tensor or np.ndarray.</p></li>
<li><p><strong>end</strong> – Ending data point as torch.Tensor or np.ndarray.</p></li>
<li><p><strong>nworkers</strong> – Number of worker processes for parallel computation.
Defaults to 1.</p></li>
<li><p><strong>bound</strong> – Constraint radius for numerical stability when computing halfspaces.
Important for numerical stability. Defaults to 1e5.</p></li>
<li><p><strong>max_polys</strong> – Maximum number of polyhedra to explore during search.
Defaults to infinity.</p></li>
<li><p><strong>show_pbar</strong> – Whether to display a progress bar. Defaults to True.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to get_shis().</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A list of Polyhedron objects representing the path</dt><dd><p>from start to end, or None if no path is found.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list or None</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the start point lies exactly on a neuron’s boundary.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.load">
<span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.load" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.parallel_add">
<span class="sig-name descname"><span class="pre">parallel_add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nworkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.parallel_add" title="Link to this definition">¶</a></dt>
<dd><p>Add multiple polyhedra from data points using parallel processing.</p>
<p>Processes a batch of data points in parallel, computing their corresponding
polyhedra and adding them to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> – A list or iterable of data points (each as torch.Tensor or np.ndarray).</p></li>
<li><p><strong>nworkers</strong> – Number of worker processes to use. If None, uses the number
of CPU cores. Defaults to None.</p></li>
<li><p><strong>bound</strong> – Constraint radius for numerical stability when computing halfspaces.
Defaults to 1e6.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to poly_calculations() and get_shis().</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A list of Polyhedron objects (or None for failed computations)</dt><dd><p>corresponding to the input points.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_regions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">highlight_regions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.plot" title="Link to this definition">¶</a></dt>
<dd><p>Plot the complex in 2D using plotly.</p>
<p>Creates a 2D visualization of the complex, showing all polyhedra as
regions in the input space. Only works for 2D input spaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label_regions</strong> – If True, add text labels showing each polyhedron’s
string representation at its center. Defaults to False.</p></li>
<li><p><strong>color</strong> – If “Wl2”, color polyhedra by their Wl2 (weight norm) value.
If None, use an equitable graph coloring. Defaults to None.</p></li>
<li><p><strong>highlight_regions</strong> – If provided, highlight these polyhedra in red.
Can be a list of Polyhedron objects or their string representations.
Defaults to None.</p></li>
<li><p><strong>ss_name</strong> – If True, use the full sign sequence as
the legend label for each polyhedron. Defaults to False.</p></li>
<li><p><strong>bound</strong> – Constraint radius for plotting bounds. Passed to each
polyhedron’s plot2d() method. Defaults to None.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to each polyhedron’s plot2d() method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A plotly figure containing the 2D plot</dt><dd><p>of the complex.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>plotly.graph_objects.Figure</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.plot3d">
<span class="sig-name descname"><span class="pre">plot3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_regions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">highlight_regions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.plot3d" title="Link to this definition">¶</a></dt>
<dd><p>Plot the complex in 3D using plotly.</p>
<p>Creates a 3D visualization of the complex, showing all polyhedra as
regions in the input space. Only works for 3D input spaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label_regions</strong> – If True, add text labels showing each polyhedron’s
string representation. Defaults to False.</p></li>
<li><p><strong>color</strong> – If “Wl2”, color polyhedra by their Wl2 (weight norm) value.
If None, use an equitable graph coloring. Defaults to None.</p></li>
<li><p><strong>highlight_regions</strong> – If provided, highlight these polyhedra in red.
Can be a list of Polyhedron objects or their string representations.
Defaults to None.</p></li>
<li><p><strong>show_axes</strong> – If True, display the coordinate axes. Defaults to False.</p></li>
<li><p><strong>project</strong> – If True, also show a projection of the complex onto the
xy plane. Defaults to True.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to each polyhedron’s plot3d() method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A plotly figure containing the 3D plot</dt><dd><p>of the complex.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>plotly.graph_objects.Figure</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.point2poly">
<span class="sig-name descname"><span class="pre">point2poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_exists</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numpy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.point2poly" title="Link to this definition">¶</a></dt>
<dd><p>Convert a data point to its corresponding Polyhedron.</p>
<p>Finds the polyhedron that contains the given data point. Does not add
the polyhedron to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A single data point as a torch.Tensor or np.ndarray.</p></li>
<li><p><strong>check_exists</strong> – If True, return the existing polyhedron from the complex
if it already exists. Defaults to True.</p></li>
<li><p><strong>numpy</strong> – If True, treat input as numpy array. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The polyhedron containing the given point.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.Polyhedron" title="relucent.Polyhedron">Polyhedron</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.point2ss">
<span class="sig-name descname"><span class="pre">point2ss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numpy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.point2ss" title="Link to this definition">¶</a></dt>
<dd><p>Convert a batch of data points to sign sequences.</p>
<p>Computes the combined sign sequence across all ReLU layers for the given
data points. Does not add the resulting polyhedra to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> – A batch of input data points as a torch.Tensor or np.ndarray.</p></li>
<li><p><strong>numpy</strong> – If True, return result as numpy array; otherwise return torch.Tensor.
Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>The sign sequences for</dt><dd><p>the input batch, with shape (batch_size, total_ReLU_neurons).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor or np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.random_walk">
<span class="sig-name descname"><span class="pre">random_walk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.random_walk" title="Link to this definition">¶</a></dt>
<dd><p>Perform random walk search of the complex.</p>
<p>Explores the complex by randomly selecting which polyhedron to explore
next from the queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – All arguments accepted by searcher().</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Search information dictionary (see searcher() documentation).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.recover_from_dual_graph">
<span class="sig-name descname"><span class="pre">recover_from_dual_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.recover_from_dual_graph" title="Link to this definition">¶</a></dt>
<dd><p>Recover a complex from its connectivity graph.</p>
<p>Reconstructs polyhedra in the complex by traversing the adjacency graph
of top-dimensional cells, using the supporting hyperplane indices stored
on edges to determine how to flip sign sequence elements. This is useful
for storing large complexes efficiently, as you only need to store the
graph structure and SHI indices on edges rather than full polyhedron data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – A networkx.Graph representing the dual graph. Edges must have
a “shi” attribute indicating the supporting hyperplane index.</p></li>
<li><p><strong>initial_ss</strong> – The sign sequence of a starting polyhedron
as torch.Tensor or np.ndarray.</p></li>
<li><p><strong>source</strong> – The node key in G representing the initial polyhedron.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>The graph with polyhedron objects stored in node</dt><dd><p>attributes under the “poly” key.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkx.Graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_ssm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.save" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.searcher">
<span class="sig-name descname"><span class="pre">searcher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_polys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">queue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nworkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_volumes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.searcher" title="Link to this definition">¶</a></dt>
<dd><p>Search for polyhedra in the complex by discovering neighbors.</p>
<p>This is a generic search method that can be configured for different
traversal strategies (BFS, DFS, random walk) by providing different
queue types. It starts from a given point and explores the complex by
crossing supporting hyperplanes to discover adjacent polyhedra.</p>
<p>See bfs(), dfs(), and random_walk() for examples of how to use this
function to define specific search strategies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> – Starting point for the search. Can be a torch.Tensor data point
or None (defaults to origin). Defaults to None.</p></li>
<li><p><strong>max_depth</strong> – Maximum search depth (number of hyperplane crossings).
Defaults to infinity.</p></li>
<li><p><strong>max_polys</strong> – Maximum number of polyhedra to discover. Defaults to infinity.</p></li>
<li><p><strong>queue</strong> – Queue object that defines the order in which polyhedra are
searched. Must have push() and pop() methods. If None, uses
BlockingQueue (FIFO). Defaults to None.</p></li>
<li><p><strong>bound</strong> – Constraint radius for numerical stability when computing halfspaces.
Important for numerical stability. Defaults to 1e5.</p></li>
<li><p><strong>nworkers</strong> – Number of worker processes for parallel computation. If None,
uses the number of CPU cores. Defaults to None.</p></li>
<li><p><strong>get_volumes</strong> – Whether to compute volumes for polyhedra when input
dimension &lt;= 6. Defaults to True.</p></li>
<li><p><strong>verbose</strong> – Whether to print progress information. Defaults to 1.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to Polyhedron.get_shis().</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Search information dictionary containing:</dt><dd><ul class="simple">
<li><p>”Search Depth”: Maximum depth reached</p></li>
<li><p>”Avg # Facets Uncorrected”: Average number of facets per polyhedron</p></li>
<li><p>”Search Time”: Elapsed time in seconds</p></li>
<li><p>”Bad SHI Computations”: List of failed computations</p></li>
<li><p>”Complete”: Whether search completed (no unprocessed items)</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the start point lies on a hyperplane (has zero in SS).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.ss2poly">
<span class="sig-name descname"><span class="pre">ss2poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_exists</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.ss2poly" title="Link to this definition">¶</a></dt>
<dd><p>Convert a sign sequence to a Polyhedron.</p>
<p>Creates a Polyhedron object from the given sign sequence. Does not add
it to the complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ss</strong> – A sign sequence as a torch.Tensor or np.ndarray.</p></li>
<li><p><strong>check_exists</strong> – If True, return the existing polyhedron from the complex
if it already exists. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The polyhedron corresponding to the given sign sequence.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.Polyhedron" title="relucent.Polyhedron">Polyhedron</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Complex.ss_iterator">
<span class="sig-name descname"><span class="pre">ss_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Complex.ss_iterator" title="Link to this definition">¶</a></dt>
<dd><p>Generate sign sequences for each ReLU layer from a batch of data points.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>batch</strong> – A batch of input data points as a torch.Tensor or np.ndarray.
Will be reshaped to match the network’s input shape.</p>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><p><em>torch.Tensor</em> –</p>
<dl class="simple">
<dt>Sign sequences for each ReLU layer in</dt><dd><p>the network, indicating the activation pattern of that layer.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Complex.dim">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">dim</span></span><a class="headerlink" href="#relucent.Complex.dim" title="Link to this definition">¶</a></dt>
<dd><p>The input dimension of the network.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="relucent.NN">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">relucent.</span></span><span class="sig-name descname"><span class="pre">NN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.NN" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Neural network class that interfaces with the rest of the package</p>
<dl class="py method">
<dt class="sig sig-object py" id="relucent.NN.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.NN.forward" title="Link to this definition">¶</a></dt>
<dd><p>Define the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.NN.get_all_layer_outputs">
<span class="sig-name descname"><span class="pre">get_all_layer_outputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.NN.get_all_layer_outputs" title="Link to this definition">¶</a></dt>
<dd><p>Get outputs from specified layers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – Input tensor to the network.</p></li>
<li><p><strong>layers</strong> – List of layer names to include. If None, includes all layers.
Defaults to None.</p></li>
<li><p><strong>verbose</strong> – If True, prints layer information. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dictionary mapping layer names to their outputs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>OrderedDict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.NN.get_grid">
<span class="sig-name descname"><span class="pre">get_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.NN.get_grid" title="Link to this definition">¶</a></dt>
<dd><p>Generate a 2D grid of input points.</p>
<p>Creates a regular grid of points in 2D space. Only works for 2D input spaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> – Half-width of the grid (grid spans [-bounds, bounds]).
Defaults to 2.</p></li>
<li><p><strong>res</strong> – Resolution (number of points per dimension). Defaults to 100.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(x_coords, y_coords, input_points) where input_points is an</dt><dd><p>array of shape (res*res, 2).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.NN.output_grid">
<span class="sig-name descname"><span class="pre">output_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.NN.output_grid" title="Link to this definition">¶</a></dt>
<dd><p>Generate a grid and compute network outputs for all points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> – Half-width of the grid. Defaults to 2.</p></li>
<li><p><strong>res</strong> – Resolution (number of points per dimension). Defaults to 100.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(x_coords, y_coords, layer_outputs) where layer_outputs is</dt><dd><p>an OrderedDict mapping layer names to outputs.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.NN.shi2weights">
<span class="sig-name descname"><span class="pre">shi2weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.NN.shi2weights" title="Link to this definition">¶</a></dt>
<dd><p>Get weights corresponding to a neuron index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shi</strong> – Index of the neuron (supporting hyperplane index).</p></li>
<li><p><strong>return_idx</strong> – If True, returns (layer_name, neuron_index_in_layer).
If False, returns a pointer to the weight tensor. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor weight vector.
If return_idx is True: (layer_name, neuron_index) tuple.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>If return_idx is False</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the neuron index is invalid.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.NN.device">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">device</span></span><a class="headerlink" href="#relucent.NN.device" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.NN.dtype">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#relucent.NN.dtype" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.NN.num_relus">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">num_relus</span></span><a class="headerlink" href="#relucent.NN.num_relus" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="relucent.Polyhedron">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">relucent.</span></span><span class="sig-name descname"><span class="pre">Polyhedron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">halfspaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a polyhedron (linear region) in d-dimensional space.</p>
<p>Several methods use Gurobi environments for optimization. If one is not
provided, an environment will be created automatically.</p>
<dl class="py method">
<dt class="sig sig-object py" id="relucent.Polyhedron.clean_data">
<span class="sig-name descname"><span class="pre">clean_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron.clean_data" title="Link to this definition">¶</a></dt>
<dd><p>Clear cached data to reduce memory usage.</p>
<p>Removes large cached properties like halfspaces, W matrix, center,
and halfspace intersection data. Keeps small properties, the sign sequence,
and the interior point.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Polyhedron.compute_properties">
<span class="sig-name descname"><span class="pre">compute_properties</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron.compute_properties" title="Link to this definition">¶</a></dt>
<dd><p>Compute additional geometric properties for low-dimensional polyhedra.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if computation succeeded.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If input dimension &gt; 6 or if computation fails.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Polyhedron.get_bounded_halfspaces">
<span class="sig-name descname"><span class="pre">get_bounded_halfspaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron.get_bounded_halfspaces" title="Link to this definition">¶</a></dt>
<dd><p>Get halfspaces after adding bounding box constraints.</p>
<p>Adds constraints that bound the space to a hypercube of radius ‘bound’
around the origin. Useful for plotting and visualization. Returns None
if the polyhedron doesn’t intersect the bounded region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bound</strong> – Radius of the bounding hypercube.</p></li>
<li><p><strong>env</strong> – Gurobi environment for feasibility checking. If None, uses
a cached environment. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Halfspaces with bounding constraints added, or</dt><dd><p>None if the polyhedron doesn’t intersect the bounded region.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Polyhedron.get_bounded_vertices">
<span class="sig-name descname"><span class="pre">get_bounded_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bound</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron.get_bounded_vertices" title="Link to this definition">¶</a></dt>
<dd><p>Get the vertices of the polyhedron within a bounding hypercube.</p>
<p>Computes the vertices of the polyhedron after intersecting it with a
hypercube of radius ‘bound’. Primarily used for plotting and visualization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bound</strong> – Radius of the bounding hypercube.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Array of vertex coordinates, or None if the</dt><dd><p>polyhedron doesn’t intersect the bounded region or computation fails.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Polyhedron.get_center_inradius">
<span class="sig-name descname"><span class="pre">get_center_inradius</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron.get_center_inradius" title="Link to this definition">¶</a></dt>
<dd><p>Get the Chebyshev center and inradius of the polyhedron.</p>
<p>Also sets self._finite to indicate if the polyhedron is finite.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>env</strong> – Gurobi environment for optimization. If None, uses a cached
environment. Defaults to None.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(center, inradius) where center is None for unbounded polyhedra.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Polyhedron.get_hs">
<span class="sig-name descname"><span class="pre">get_hs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_all_Ab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron.get_hs" title="Link to this definition">¶</a></dt>
<dd><p>Get the halfspace representation of this polyhedron.</p>
<p>Computes the halfspaces (inequality constraints) that define the polyhedron
from all neurons in the network. The result includes constraints from
every neuron, not just the supporting hyperplanes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – Optional input data to the network for verification. If provided,
checks that computed outputs match network outputs. Defaults to None.</p></li>
<li><p><strong>get_all_Ab</strong> – If True, returns all intermediate affine maps (A, b) for
each layer instead of just the final halfspaces. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(halfspaces, W, b) where:</dt><dd><ul class="simple">
<li><p>halfspaces: Array of shape (n_constraints, n_dim+1) with bias terms</p></li>
<li><p>W: Affine transformation matrix</p></li>
<li><p>b: Affine transformation bias vector</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Polyhedron.get_interior_point">
<span class="sig-name descname"><span class="pre">get_interior_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron.get_interior_point" title="Link to this definition">¶</a></dt>
<dd><p>Get a point inside the polyhedron.</p>
<p>Computes an interior point of the polyhedron. If the center is already
computed, uses that; otherwise solves for an interior point using Gurobi.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>env</strong> – Gurobi environment for optimization. If None, uses a cached
environment. Defaults to None.</p></li>
<li><p><strong>max_radius</strong> – Maximum radius constraint for the search. If None, uses
self.MAX_RADIUS. Defaults to None.</p></li>
<li><p><strong>zero_indices</strong> – Indices of sign sequence elements that are zero (for
lower-dimensional polyhedra). Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An interior point of the polyhedron.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If no interior point can be found.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Polyhedron.get_shis">
<span class="sig-name descname"><span class="pre">get_shis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">collect_info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e+100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shi_pbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron.get_shis" title="Link to this definition">¶</a></dt>
<dd><p>Get supporting halfspace indices (SHIs) for this polyhedron.</p>
<p>Computes the indices of non-redundant halfspaces that form the boundary
of this polyhedron. These correspond to neurons whose boundaries (BHs)
are actually part of the polyhedron’s boundary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collect_info</strong> – If True, collects additional debugging information
about the computations. If “All”, collects even more detailed info.
Defaults to False.</p></li>
<li><p><strong>bound</strong> – Defines the hypercube bounding the space for numerical stability.
Defaults to infinity.</p></li>
<li><p><strong>subset</strong> – Indices of neurons/halfspaces to consider. If None, considers
all halfspaces. Defaults to None.</p></li>
<li><p><strong>tol</strong> – Inequality tolerance to improve numerical stability. Defaults to 1e-6.</p></li>
<li><p><strong>new_method</strong> – If True, uses an extra computation that doesn’t improve
runtime. Defaults to False.</p></li>
<li><p><strong>env</strong> – Gurobi environment for optimization. If None, uses a cached
environment. Defaults to None.</p></li>
<li><p><strong>shi_pbar</strong> – If True, shows a progress bar during computation. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>If collect_info is False, returns a list of SHI indices.</dt><dd><p>If collect_info is True, returns (shis, info) where info is a list
of dictionaries with computation details.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list or tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the optimization model fails.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Polyhedron.is_face_of">
<span class="sig-name descname"><span class="pre">is_face_of</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron.is_face_of" title="Link to this definition">¶</a></dt>
<dd><p>Check if this polyhedron is a face of another polyhedron.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – Another Polyhedron object to check against.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if this polyhedron is a face of the other.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Polyhedron.nflips">
<span class="sig-name descname"><span class="pre">nflips</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron.nflips" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the number of non-zero sign sequence elements that differ.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – Another Polyhedron object to compare with.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of sign sequence elements that differ.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Polyhedron.plot2d">
<span class="sig-name descname"><span class="pre">plot2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'toself'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">showlegend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron.plot2d" title="Link to this definition">¶</a></dt>
<dd><p>Plot the polyhedron in 2D using plotly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fill</strong> – Fill mode passed to go.Scatter. Defaults to “toself”.</p></li>
<li><p><strong>showlegend</strong> – Whether to show in legend. Defaults to False.</p></li>
<li><p><strong>bound</strong> – Radius of the bounding hypercube for vertex computation.
Defaults to 1000.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to go.Scatter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A plotly Scatter trace, or None</dt><dd><p>if plotting fails.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>plotly.graph_objects.Scatter or None</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the polyhedron is not 2D.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="relucent.Polyhedron.plot3d">
<span class="sig-name descname"><span class="pre">plot3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'toself'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">showlegend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.Polyhedron.plot3d" title="Link to this definition">¶</a></dt>
<dd><p>Plot the polyhedron in 3D using plotly.</p>
<p>Creates a 3D mesh plot of the polyhedron. The z-coordinates are computed
by passing the 2D vertices through the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fill</strong> – Fill mode (not used for 3D plots). Defaults to “toself”.</p></li>
<li><p><strong>showlegend</strong> – Whether to show in legend. Defaults to False.</p></li>
<li><p><strong>bound</strong> – Radius of the bounding hypercube for vertex computation.
Defaults to 1000.</p></li>
<li><p><strong>project</strong> – If a number, projects the polyhedron onto this z-value
instead of computing it from the network. Defaults to None.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments passed to go.Mesh3d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Dictionary with ‘mesh’ and ‘outline’ keys containing</dt><dd><p>plotly traces, or None if plotting fails.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict or None</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the polyhedron is not 2D.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="relucent.Polyhedron.MAX_RADIUS">
<span class="sig-name descname"><span class="pre">MAX_RADIUS</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">100</span></span><a class="headerlink" href="#relucent.Polyhedron.MAX_RADIUS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.W">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">W</span></span><a class="headerlink" href="#relucent.Polyhedron.W" title="Link to this definition">¶</a></dt>
<dd><p>Affine transformation matrix W such that the polyhedron maps to W*x + b.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Transformation matrix.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor or np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.Wl2">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">Wl2</span></span><a class="headerlink" href="#relucent.Polyhedron.Wl2" title="Link to this definition">¶</a></dt>
<dd><p>L2 norm of the transformation matrix W.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.b">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">b</span></span><a class="headerlink" href="#relucent.Polyhedron.b" title="Link to this definition">¶</a></dt>
<dd><p>Affine transformation bias vector such that the polyhedron maps to W*x + b.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Bias vector.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor or np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.center">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">center</span></span><a class="headerlink" href="#relucent.Polyhedron.center" title="Link to this definition">¶</a></dt>
<dd><p>Chebyshev center of the polyhedron for finite polyhedra, or None for unbounded polyhedra.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.ch">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">ch</span></span><a class="headerlink" href="#relucent.Polyhedron.ch" title="Link to this definition">¶</a></dt>
<dd><p>Convex hull of the polyhedron for finite polyhedra.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.finite">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">finite</span></span><a class="headerlink" href="#relucent.Polyhedron.finite" title="Link to this definition">¶</a></dt>
<dd><p>Whether the polyhedron is bounded (finite).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.halfspaces">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">halfspaces</span></span><a class="headerlink" href="#relucent.Polyhedron.halfspaces" title="Link to this definition">¶</a></dt>
<dd><p>Halfspace representation of the polyhedron.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>Array of shape (n_constraints, n_dim+1)</dt><dd><p>where each row is [a1, a2, …, ad, b] representing the
constraint a^T x + b &lt;= 0.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor or np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.hs">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">hs</span></span><a class="headerlink" href="#relucent.Polyhedron.hs" title="Link to this definition">¶</a></dt>
<dd><p>Halfspace intersection object from scipy.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.inradius">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">inradius</span></span><a class="headerlink" href="#relucent.Polyhedron.inradius" title="Link to this definition">¶</a></dt>
<dd><p>Inradius of the polyhedron (radius of largest inscribed ball), infinity for unbounded polyhedra.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.interior_point">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">interior_point</span></span><a class="headerlink" href="#relucent.Polyhedron.interior_point" title="Link to this definition">¶</a></dt>
<dd><p>A point guaranteed to be inside the polyhedron.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.interior_point_norm">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">interior_point_norm</span></span><a class="headerlink" href="#relucent.Polyhedron.interior_point_norm" title="Link to this definition">¶</a></dt>
<dd><p>L2 norm of the interior point.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.num_dead_relus">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">num_dead_relus</span></span><a class="headerlink" href="#relucent.Polyhedron.num_dead_relus" title="Link to this definition">¶</a></dt>
<dd><p>Number of dead ReLU neurons (neurons always outputting zero).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Count of ReLU neurons that are always inactive for this polyhedron.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.num_faces">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">num_faces</span></span><a class="headerlink" href="#relucent.Polyhedron.num_faces" title="Link to this definition">¶</a></dt>
<dd><p>Alias for Polyhedron.num_shis</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.num_shis">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">num_shis</span></span><a class="headerlink" href="#relucent.Polyhedron.num_shis" title="Link to this definition">¶</a></dt>
<dd><p>Number of faces.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.point">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">point</span></span><a class="headerlink" href="#relucent.Polyhedron.point" title="Link to this definition">¶</a></dt>
<dd><p>The center if available, otherwise an interior point.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.shis">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">shis</span></span><a class="headerlink" href="#relucent.Polyhedron.shis" title="Link to this definition">¶</a></dt>
<dd><p>Supporting halfspace indices (SHIs).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.tag">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">tag</span></span><a class="headerlink" href="#relucent.Polyhedron.tag" title="Link to this definition">¶</a></dt>
<dd><p>Unique tag for this polyhedron, computed as a hashable
representation of the sign sequence.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.vertex_set">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">vertex_set</span></span><a class="headerlink" href="#relucent.Polyhedron.vertex_set" title="Link to this definition">¶</a></dt>
<dd><p>Set of vertices of the polyhedron (not always reliable).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.vertices">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">vertices</span></span><a class="headerlink" href="#relucent.Polyhedron.vertices" title="Link to this definition">¶</a></dt>
<dd><p>Vertices of the polyhedron (not always reliable).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Array of vertex coordinates.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="relucent.Polyhedron.volume">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">volume</span></span><a class="headerlink" href="#relucent.Polyhedron.volume" title="Link to this definition">¶</a></dt>
<dd><p>Volume of the polyhedron, infinity for unbounded polyhedra,
or -1 if computation fails.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="relucent.SSManager">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">relucent.</span></span><span class="sig-name descname"><span class="pre">SSManager</span></span><a class="headerlink" href="#relucent.SSManager" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Manages storage and lookup of sign sequences.</p>
<p>This class provides a dictionary-like interface for storing and retrieving
sign sequences (arrays with values in {-1, 0, 1}). It maintains an index
mapping and allows efficient membership testing and retrieval.</p>
<p>Sign sequences are encoded as hashable tags for efficient storage and lookup.</p>
<dl class="py method">
<dt class="sig sig-object py" id="relucent.SSManager.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ss</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.SSManager.add" title="Link to this definition">¶</a></dt>
<dd><p>Add a sign sequence to the manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ss</strong> – A sign sequence as torch.Tensor or np.ndarray.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.convert">
<span class="sig-prename descclassname"><span class="pre">relucent.</span></span><span class="sig-name descname"><span class="pre">convert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Module</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Module</span></span></span><a class="headerlink" href="#relucent.convert" title="Link to this definition">¶</a></dt>
<dd><p>Convert a PyTorch model to canonical NN format.</p>
<p>Converts various PyTorch layer types (Conv2d, AvgPool2d, etc.) into the
canonical format consisting only of Linear and ReLU layers.</p>
<dl class="simple">
<dt>Supported layer types:</dt><dd><ul class="simple">
<li><p>Linear, ReLU: Passed through unchanged</p></li>
<li><p>Conv2d: Converted to Linear</p></li>
<li><p>AvgPool2d: Converted to Linear (if kernel_size == stride)</p></li>
<li><p>Flatten: Handled automatically</p></li>
<li><p>Dropout: Removed (not needed for inference)</p></li>
<li><p>LogSoftmax: Stops conversion (output layer)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>model</strong> – A PyTorch nn.Module with an ‘input_shape’ attribute and ‘layers’
attribute containing an OrderedDict of layers.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new NN object in canonical format.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.NN" title="relucent.NN">NN</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If an unsupported layer type is encountered.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.get_env">
<span class="sig-prename descclassname"><span class="pre">relucent.</span></span><span class="sig-name descname"><span class="pre">get_env</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#relucent.get_env" title="Link to this definition">¶</a></dt>
<dd><p>Get a cached Gurobi environment.</p>
<p>Creates and caches a Gurobi environment with logging disabled. This avoids
the overhead of creating multiple environments. For more control over the
environment, create and pass one directly to functions that need it.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A Gurobi environment with logging disabled.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>gurobipy.Env</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.get_mlp_model">
<span class="sig-prename descclassname"><span class="pre">relucent.</span></span><span class="sig-name descname"><span class="pre">get_mlp_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">widths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_last_relu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.get_mlp_model" title="Link to this definition">¶</a></dt>
<dd><p>Create an NN object for a multi-layer perceptron (MLP).</p>
<p>Constructs a fully connected neural network with the specified layer widths.
Each layer (except optionally the last) is followed by a ReLU activation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>widths</strong> – List of integers specifying the number of neurons in each layer,
including the input layer. For example, [2, 10, 5, 1] creates a
network with input dimension 2, two hidden layers with 10 and 5 neurons,
and output dimension 1.</p></li>
<li><p><strong>add_last_relu</strong> – If True, adds a ReLU after the last layer. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A configured neural network object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#relucent.NN" title="relucent.NN">NN</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.set_seeds">
<span class="sig-prename descclassname"><span class="pre">relucent.</span></span><span class="sig-name descname"><span class="pre">set_seeds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.set_seeds" title="Link to this definition">¶</a></dt>
<dd><p>Set all RNG seeds to a given value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>seed</strong> – Integer seed value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="relucent.split_sequential">
<span class="sig-prename descclassname"><span class="pre">relucent.</span></span><span class="sig-name descname"><span class="pre">split_sequential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_layer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#relucent.split_sequential" title="Link to this definition">¶</a></dt>
<dd><p>Split a neural network into two sequential parts.</p>
<p>Creates two separate NN objects by splitting the model at a specified layer.
The first network contains layers up to and including split_layer, and the
second contains all subsequent layers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – The NN object to split.</p></li>
<li><p><strong>split_layer</strong> – Name of the layer at which to split (this layer goes to
the first network).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(nn1, nn2) where nn1 contains layers up to split_layer and</dt><dd><p>nn2 contains the remaining layers.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">relucent package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-relucent.complex">relucent.complex module</a><ul>
<li><a class="reference internal" href="#relucent.complex.Complex"><code class="docutils literal notranslate"><span class="pre">Complex</span></code></a><ul>
<li><a class="reference internal" href="#relucent.complex.Complex.add_point"><code class="docutils literal notranslate"><span class="pre">Complex.add_point()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.add_polyhedron"><code class="docutils literal notranslate"><span class="pre">Complex.add_polyhedron()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.add_ss"><code class="docutils literal notranslate"><span class="pre">Complex.add_ss()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.adjacent_polyhedra"><code class="docutils literal notranslate"><span class="pre">Complex.adjacent_polyhedra()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.bfs"><code class="docutils literal notranslate"><span class="pre">Complex.bfs()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.clean_data"><code class="docutils literal notranslate"><span class="pre">Complex.clean_data()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.dfs"><code class="docutils literal notranslate"><span class="pre">Complex.dfs()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.get_dual_graph"><code class="docutils literal notranslate"><span class="pre">Complex.get_dual_graph()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.get_poly_attrs"><code class="docutils literal notranslate"><span class="pre">Complex.get_poly_attrs()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.greedy_path"><code class="docutils literal notranslate"><span class="pre">Complex.greedy_path()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.hamming_astar"><code class="docutils literal notranslate"><span class="pre">Complex.hamming_astar()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.load"><code class="docutils literal notranslate"><span class="pre">Complex.load()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.parallel_add"><code class="docutils literal notranslate"><span class="pre">Complex.parallel_add()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.plot"><code class="docutils literal notranslate"><span class="pre">Complex.plot()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.plot3d"><code class="docutils literal notranslate"><span class="pre">Complex.plot3d()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.point2poly"><code class="docutils literal notranslate"><span class="pre">Complex.point2poly()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.point2ss"><code class="docutils literal notranslate"><span class="pre">Complex.point2ss()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.random_walk"><code class="docutils literal notranslate"><span class="pre">Complex.random_walk()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.recover_from_dual_graph"><code class="docutils literal notranslate"><span class="pre">Complex.recover_from_dual_graph()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.save"><code class="docutils literal notranslate"><span class="pre">Complex.save()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.searcher"><code class="docutils literal notranslate"><span class="pre">Complex.searcher()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.ss2poly"><code class="docutils literal notranslate"><span class="pre">Complex.ss2poly()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.ss_iterator"><code class="docutils literal notranslate"><span class="pre">Complex.ss_iterator()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.Complex.dim"><code class="docutils literal notranslate"><span class="pre">Complex.dim</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#relucent.complex.astar_calculations"><code class="docutils literal notranslate"><span class="pre">astar_calculations()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.get_ip"><code class="docutils literal notranslate"><span class="pre">get_ip()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.poly_calculations"><code class="docutils literal notranslate"><span class="pre">poly_calculations()</span></code></a></li>
<li><a class="reference internal" href="#relucent.complex.set_globals"><code class="docutils literal notranslate"><span class="pre">set_globals()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-relucent.convert_model">relucent.convert_model module</a><ul>
<li><a class="reference internal" href="#relucent.convert_model.avgpool2d_to_affine"><code class="docutils literal notranslate"><span class="pre">avgpool2d_to_affine()</span></code></a></li>
<li><a class="reference internal" href="#relucent.convert_model.combine_linear_layers"><code class="docutils literal notranslate"><span class="pre">combine_linear_layers()</span></code></a></li>
<li><a class="reference internal" href="#relucent.convert_model.convert"><code class="docutils literal notranslate"><span class="pre">convert()</span></code></a></li>
<li><a class="reference internal" href="#relucent.convert_model.flatten_to_affine"><code class="docutils literal notranslate"><span class="pre">flatten_to_affine()</span></code></a></li>
<li><a class="reference internal" href="#relucent.convert_model.torch_conv_layer_to_affine"><code class="docutils literal notranslate"><span class="pre">torch_conv_layer_to_affine()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-relucent.model">relucent.model module</a><ul>
<li><a class="reference internal" href="#relucent.model.NN"><code class="docutils literal notranslate"><span class="pre">NN</span></code></a><ul>
<li><a class="reference internal" href="#relucent.model.NN.forward"><code class="docutils literal notranslate"><span class="pre">NN.forward()</span></code></a></li>
<li><a class="reference internal" href="#relucent.model.NN.get_all_layer_outputs"><code class="docutils literal notranslate"><span class="pre">NN.get_all_layer_outputs()</span></code></a></li>
<li><a class="reference internal" href="#relucent.model.NN.get_grid"><code class="docutils literal notranslate"><span class="pre">NN.get_grid()</span></code></a></li>
<li><a class="reference internal" href="#relucent.model.NN.output_grid"><code class="docutils literal notranslate"><span class="pre">NN.output_grid()</span></code></a></li>
<li><a class="reference internal" href="#relucent.model.NN.shi2weights"><code class="docutils literal notranslate"><span class="pre">NN.shi2weights()</span></code></a></li>
<li><a class="reference internal" href="#relucent.model.NN.device"><code class="docutils literal notranslate"><span class="pre">NN.device</span></code></a></li>
<li><a class="reference internal" href="#relucent.model.NN.dtype"><code class="docutils literal notranslate"><span class="pre">NN.dtype</span></code></a></li>
<li><a class="reference internal" href="#relucent.model.NN.num_relus"><code class="docutils literal notranslate"><span class="pre">NN.num_relus</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#relucent.model.get_mlp_model"><code class="docutils literal notranslate"><span class="pre">get_mlp_model()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-relucent.poly">relucent.poly module</a><ul>
<li><a class="reference internal" href="#relucent.poly.Polyhedron"><code class="docutils literal notranslate"><span class="pre">Polyhedron</span></code></a><ul>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.clean_data"><code class="docutils literal notranslate"><span class="pre">Polyhedron.clean_data()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.compute_properties"><code class="docutils literal notranslate"><span class="pre">Polyhedron.compute_properties()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.get_bounded_halfspaces"><code class="docutils literal notranslate"><span class="pre">Polyhedron.get_bounded_halfspaces()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.get_bounded_vertices"><code class="docutils literal notranslate"><span class="pre">Polyhedron.get_bounded_vertices()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.get_center_inradius"><code class="docutils literal notranslate"><span class="pre">Polyhedron.get_center_inradius()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.get_hs"><code class="docutils literal notranslate"><span class="pre">Polyhedron.get_hs()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.get_interior_point"><code class="docutils literal notranslate"><span class="pre">Polyhedron.get_interior_point()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.get_shis"><code class="docutils literal notranslate"><span class="pre">Polyhedron.get_shis()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.is_face_of"><code class="docutils literal notranslate"><span class="pre">Polyhedron.is_face_of()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.nflips"><code class="docutils literal notranslate"><span class="pre">Polyhedron.nflips()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.plot2d"><code class="docutils literal notranslate"><span class="pre">Polyhedron.plot2d()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.plot3d"><code class="docutils literal notranslate"><span class="pre">Polyhedron.plot3d()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.MAX_RADIUS"><code class="docutils literal notranslate"><span class="pre">Polyhedron.MAX_RADIUS</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.W"><code class="docutils literal notranslate"><span class="pre">Polyhedron.W</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.Wl2"><code class="docutils literal notranslate"><span class="pre">Polyhedron.Wl2</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.b"><code class="docutils literal notranslate"><span class="pre">Polyhedron.b</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.center"><code class="docutils literal notranslate"><span class="pre">Polyhedron.center</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.ch"><code class="docutils literal notranslate"><span class="pre">Polyhedron.ch</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.finite"><code class="docutils literal notranslate"><span class="pre">Polyhedron.finite</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.halfspaces"><code class="docutils literal notranslate"><span class="pre">Polyhedron.halfspaces</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.hs"><code class="docutils literal notranslate"><span class="pre">Polyhedron.hs</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.inradius"><code class="docutils literal notranslate"><span class="pre">Polyhedron.inradius</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.interior_point"><code class="docutils literal notranslate"><span class="pre">Polyhedron.interior_point</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.interior_point_norm"><code class="docutils literal notranslate"><span class="pre">Polyhedron.interior_point_norm</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.num_dead_relus"><code class="docutils literal notranslate"><span class="pre">Polyhedron.num_dead_relus</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.num_faces"><code class="docutils literal notranslate"><span class="pre">Polyhedron.num_faces</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.num_shis"><code class="docutils literal notranslate"><span class="pre">Polyhedron.num_shis</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.point"><code class="docutils literal notranslate"><span class="pre">Polyhedron.point</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.shis"><code class="docutils literal notranslate"><span class="pre">Polyhedron.shis</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.tag"><code class="docutils literal notranslate"><span class="pre">Polyhedron.tag</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.vertex_set"><code class="docutils literal notranslate"><span class="pre">Polyhedron.vertex_set</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.vertices"><code class="docutils literal notranslate"><span class="pre">Polyhedron.vertices</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.Polyhedron.volume"><code class="docutils literal notranslate"><span class="pre">Polyhedron.volume</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#relucent.poly.encode_ss"><code class="docutils literal notranslate"><span class="pre">encode_ss()</span></code></a></li>
<li><a class="reference internal" href="#relucent.poly.solve_radius"><code class="docutils literal notranslate"><span class="pre">solve_radius()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-relucent.ss">relucent.ss module</a><ul>
<li><a class="reference internal" href="#relucent.ss.SSManager"><code class="docutils literal notranslate"><span class="pre">SSManager</span></code></a><ul>
<li><a class="reference internal" href="#relucent.ss.SSManager.add"><code class="docutils literal notranslate"><span class="pre">SSManager.add()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#relucent.ss.SSPriorityQueue"><code class="docutils literal notranslate"><span class="pre">SSPriorityQueue</span></code></a><ul>
<li><a class="reference internal" href="#relucent.ss.SSPriorityQueue.pop"><code class="docutils literal notranslate"><span class="pre">SSPriorityQueue.pop()</span></code></a></li>
<li><a class="reference internal" href="#relucent.ss.SSPriorityQueue.push"><code class="docutils literal notranslate"><span class="pre">SSPriorityQueue.push()</span></code></a></li>
<li><a class="reference internal" href="#relucent.ss.SSPriorityQueue.remove_task"><code class="docutils literal notranslate"><span class="pre">SSPriorityQueue.remove_task()</span></code></a></li>
<li><a class="reference internal" href="#relucent.ss.SSPriorityQueue.REMOVED"><code class="docutils literal notranslate"><span class="pre">SSPriorityQueue.REMOVED</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-relucent.utils">relucent.utils module</a><ul>
<li><a class="reference internal" href="#relucent.utils.BlockingQueue"><code class="docutils literal notranslate"><span class="pre">BlockingQueue</span></code></a><ul>
<li><a class="reference internal" href="#relucent.utils.BlockingQueue.close"><code class="docutils literal notranslate"><span class="pre">BlockingQueue.close()</span></code></a></li>
<li><a class="reference internal" href="#relucent.utils.BlockingQueue.pop"><code class="docutils literal notranslate"><span class="pre">BlockingQueue.pop()</span></code></a></li>
<li><a class="reference internal" href="#relucent.utils.BlockingQueue.push"><code class="docutils literal notranslate"><span class="pre">BlockingQueue.push()</span></code></a></li>
<li><a class="reference internal" href="#relucent.utils.BlockingQueue.stopFlag"><code class="docutils literal notranslate"><span class="pre">BlockingQueue.stopFlag</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#relucent.utils.NonBlockingQueue"><code class="docutils literal notranslate"><span class="pre">NonBlockingQueue</span></code></a><ul>
<li><a class="reference internal" href="#relucent.utils.NonBlockingQueue.close"><code class="docutils literal notranslate"><span class="pre">NonBlockingQueue.close()</span></code></a></li>
<li><a class="reference internal" href="#relucent.utils.NonBlockingQueue.pop"><code class="docutils literal notranslate"><span class="pre">NonBlockingQueue.pop()</span></code></a></li>
<li><a class="reference internal" href="#relucent.utils.NonBlockingQueue.push"><code class="docutils literal notranslate"><span class="pre">NonBlockingQueue.push()</span></code></a></li>
<li><a class="reference internal" href="#relucent.utils.NonBlockingQueue.stopFlag"><code class="docutils literal notranslate"><span class="pre">NonBlockingQueue.stopFlag</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#relucent.utils.data_graph"><code class="docutils literal notranslate"><span class="pre">data_graph()</span></code></a></li>
<li><a class="reference internal" href="#relucent.utils.get_colors"><code class="docutils literal notranslate"><span class="pre">get_colors()</span></code></a></li>
<li><a class="reference internal" href="#relucent.utils.get_env"><code class="docutils literal notranslate"><span class="pre">get_env()</span></code></a></li>
<li><a class="reference internal" href="#relucent.utils.set_seeds"><code class="docutils literal notranslate"><span class="pre">set_seeds()</span></code></a></li>
<li><a class="reference internal" href="#relucent.utils.split_sequential"><code class="docutils literal notranslate"><span class="pre">split_sequential()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-relucent">Module contents</a><ul>
<li><a class="reference internal" href="#relucent.Complex"><code class="docutils literal notranslate"><span class="pre">Complex</span></code></a><ul>
<li><a class="reference internal" href="#relucent.Complex.add_point"><code class="docutils literal notranslate"><span class="pre">Complex.add_point()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.add_polyhedron"><code class="docutils literal notranslate"><span class="pre">Complex.add_polyhedron()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.add_ss"><code class="docutils literal notranslate"><span class="pre">Complex.add_ss()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.adjacent_polyhedra"><code class="docutils literal notranslate"><span class="pre">Complex.adjacent_polyhedra()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.bfs"><code class="docutils literal notranslate"><span class="pre">Complex.bfs()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.clean_data"><code class="docutils literal notranslate"><span class="pre">Complex.clean_data()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.dfs"><code class="docutils literal notranslate"><span class="pre">Complex.dfs()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.get_dual_graph"><code class="docutils literal notranslate"><span class="pre">Complex.get_dual_graph()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.get_poly_attrs"><code class="docutils literal notranslate"><span class="pre">Complex.get_poly_attrs()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.greedy_path"><code class="docutils literal notranslate"><span class="pre">Complex.greedy_path()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.hamming_astar"><code class="docutils literal notranslate"><span class="pre">Complex.hamming_astar()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.load"><code class="docutils literal notranslate"><span class="pre">Complex.load()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.parallel_add"><code class="docutils literal notranslate"><span class="pre">Complex.parallel_add()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.plot"><code class="docutils literal notranslate"><span class="pre">Complex.plot()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.plot3d"><code class="docutils literal notranslate"><span class="pre">Complex.plot3d()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.point2poly"><code class="docutils literal notranslate"><span class="pre">Complex.point2poly()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.point2ss"><code class="docutils literal notranslate"><span class="pre">Complex.point2ss()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.random_walk"><code class="docutils literal notranslate"><span class="pre">Complex.random_walk()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.recover_from_dual_graph"><code class="docutils literal notranslate"><span class="pre">Complex.recover_from_dual_graph()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.save"><code class="docutils literal notranslate"><span class="pre">Complex.save()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.searcher"><code class="docutils literal notranslate"><span class="pre">Complex.searcher()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.ss2poly"><code class="docutils literal notranslate"><span class="pre">Complex.ss2poly()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.ss_iterator"><code class="docutils literal notranslate"><span class="pre">Complex.ss_iterator()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Complex.dim"><code class="docutils literal notranslate"><span class="pre">Complex.dim</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#relucent.NN"><code class="docutils literal notranslate"><span class="pre">NN</span></code></a><ul>
<li><a class="reference internal" href="#relucent.NN.forward"><code class="docutils literal notranslate"><span class="pre">NN.forward()</span></code></a></li>
<li><a class="reference internal" href="#relucent.NN.get_all_layer_outputs"><code class="docutils literal notranslate"><span class="pre">NN.get_all_layer_outputs()</span></code></a></li>
<li><a class="reference internal" href="#relucent.NN.get_grid"><code class="docutils literal notranslate"><span class="pre">NN.get_grid()</span></code></a></li>
<li><a class="reference internal" href="#relucent.NN.output_grid"><code class="docutils literal notranslate"><span class="pre">NN.output_grid()</span></code></a></li>
<li><a class="reference internal" href="#relucent.NN.shi2weights"><code class="docutils literal notranslate"><span class="pre">NN.shi2weights()</span></code></a></li>
<li><a class="reference internal" href="#relucent.NN.device"><code class="docutils literal notranslate"><span class="pre">NN.device</span></code></a></li>
<li><a class="reference internal" href="#relucent.NN.dtype"><code class="docutils literal notranslate"><span class="pre">NN.dtype</span></code></a></li>
<li><a class="reference internal" href="#relucent.NN.num_relus"><code class="docutils literal notranslate"><span class="pre">NN.num_relus</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#relucent.Polyhedron"><code class="docutils literal notranslate"><span class="pre">Polyhedron</span></code></a><ul>
<li><a class="reference internal" href="#relucent.Polyhedron.clean_data"><code class="docutils literal notranslate"><span class="pre">Polyhedron.clean_data()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.compute_properties"><code class="docutils literal notranslate"><span class="pre">Polyhedron.compute_properties()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.get_bounded_halfspaces"><code class="docutils literal notranslate"><span class="pre">Polyhedron.get_bounded_halfspaces()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.get_bounded_vertices"><code class="docutils literal notranslate"><span class="pre">Polyhedron.get_bounded_vertices()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.get_center_inradius"><code class="docutils literal notranslate"><span class="pre">Polyhedron.get_center_inradius()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.get_hs"><code class="docutils literal notranslate"><span class="pre">Polyhedron.get_hs()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.get_interior_point"><code class="docutils literal notranslate"><span class="pre">Polyhedron.get_interior_point()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.get_shis"><code class="docutils literal notranslate"><span class="pre">Polyhedron.get_shis()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.is_face_of"><code class="docutils literal notranslate"><span class="pre">Polyhedron.is_face_of()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.nflips"><code class="docutils literal notranslate"><span class="pre">Polyhedron.nflips()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.plot2d"><code class="docutils literal notranslate"><span class="pre">Polyhedron.plot2d()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.plot3d"><code class="docutils literal notranslate"><span class="pre">Polyhedron.plot3d()</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.MAX_RADIUS"><code class="docutils literal notranslate"><span class="pre">Polyhedron.MAX_RADIUS</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.W"><code class="docutils literal notranslate"><span class="pre">Polyhedron.W</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.Wl2"><code class="docutils literal notranslate"><span class="pre">Polyhedron.Wl2</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.b"><code class="docutils literal notranslate"><span class="pre">Polyhedron.b</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.center"><code class="docutils literal notranslate"><span class="pre">Polyhedron.center</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.ch"><code class="docutils literal notranslate"><span class="pre">Polyhedron.ch</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.finite"><code class="docutils literal notranslate"><span class="pre">Polyhedron.finite</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.halfspaces"><code class="docutils literal notranslate"><span class="pre">Polyhedron.halfspaces</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.hs"><code class="docutils literal notranslate"><span class="pre">Polyhedron.hs</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.inradius"><code class="docutils literal notranslate"><span class="pre">Polyhedron.inradius</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.interior_point"><code class="docutils literal notranslate"><span class="pre">Polyhedron.interior_point</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.interior_point_norm"><code class="docutils literal notranslate"><span class="pre">Polyhedron.interior_point_norm</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.num_dead_relus"><code class="docutils literal notranslate"><span class="pre">Polyhedron.num_dead_relus</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.num_faces"><code class="docutils literal notranslate"><span class="pre">Polyhedron.num_faces</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.num_shis"><code class="docutils literal notranslate"><span class="pre">Polyhedron.num_shis</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.point"><code class="docutils literal notranslate"><span class="pre">Polyhedron.point</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.shis"><code class="docutils literal notranslate"><span class="pre">Polyhedron.shis</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.tag"><code class="docutils literal notranslate"><span class="pre">Polyhedron.tag</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.vertex_set"><code class="docutils literal notranslate"><span class="pre">Polyhedron.vertex_set</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.vertices"><code class="docutils literal notranslate"><span class="pre">Polyhedron.vertices</span></code></a></li>
<li><a class="reference internal" href="#relucent.Polyhedron.volume"><code class="docutils literal notranslate"><span class="pre">Polyhedron.volume</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#relucent.SSManager"><code class="docutils literal notranslate"><span class="pre">SSManager</span></code></a><ul>
<li><a class="reference internal" href="#relucent.SSManager.add"><code class="docutils literal notranslate"><span class="pre">SSManager.add()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#relucent.convert"><code class="docutils literal notranslate"><span class="pre">convert()</span></code></a></li>
<li><a class="reference internal" href="#relucent.get_env"><code class="docutils literal notranslate"><span class="pre">get_env()</span></code></a></li>
<li><a class="reference internal" href="#relucent.get_mlp_model"><code class="docutils literal notranslate"><span class="pre">get_mlp_model()</span></code></a></li>
<li><a class="reference internal" href="#relucent.set_seeds"><code class="docutils literal notranslate"><span class="pre">set_seeds()</span></code></a></li>
<li><a class="reference internal" href="#relucent.split_sequential"><code class="docutils literal notranslate"><span class="pre">split_sequential()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/relucent.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2026, Blake B. Gaines.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 9.1.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/relucent.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>